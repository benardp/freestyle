<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//$LANGUAGE"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Freestyle: Silhouette.h Source File</title>
<link rel="stylesheet" href="grey.css" type="text/css">
</head>
<body>

<b>
<table width='100%' border='0' cellspacing='0' cellpadding='0'>
<tr>
<td align='center'><a href="http://freestyle.sourceforge.net">h<font class="brighttitle"> o m e</font></a></td>
<td align='center'><a href="index.html">d<font class="brighttitle"> o c u m e n t a t i o n</font></a></td>
<td align='center'><a href="hierarchy.html">c<font class="brighttitle"> l a s s   </font>h <font class="brighttitle"> i e r a r c h y</font></a></td>
</tr>
</table>
<div class="brighttitle"><hr/></div>
</b>
<div class="corpus">
<!-- Generated by Doxygen 1.5.1 -->
<h1>Silhouette.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//</span>
<a name="l00002"></a>00002 <span class="comment">//  Filename         : Silhouette.h</span>
<a name="l00003"></a>00003 <span class="comment">//  Author(s)        : Stephane Grabli</span>
<a name="l00004"></a>00004 <span class="comment">//  Purpose          : Classes to define a silhouette structure</span>
<a name="l00005"></a>00005 <span class="comment">//  Date of creation : 25/03/2002</span>
<a name="l00006"></a>00006 <span class="comment">//</span>
<a name="l00008"></a>00008 <span class="comment"></span>
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 <span class="comment">//</span>
<a name="l00011"></a>00011 <span class="comment">//  Copyright (C) : Please refer to the COPYRIGHT file distributed </span>
<a name="l00012"></a>00012 <span class="comment">//   with this source distribution. </span>
<a name="l00013"></a>00013 <span class="comment">//</span>
<a name="l00014"></a>00014 <span class="comment">//  This program is free software; you can redistribute it and/or</span>
<a name="l00015"></a>00015 <span class="comment">//  modify it under the terms of the GNU General Public License</span>
<a name="l00016"></a>00016 <span class="comment">//  as published by the Free Software Foundation; either version 2</span>
<a name="l00017"></a>00017 <span class="comment">//  of the License, or (at your option) any later version.</span>
<a name="l00018"></a>00018 <span class="comment">//</span>
<a name="l00019"></a>00019 <span class="comment">//  This program is distributed in the hope that it will be useful,</span>
<a name="l00020"></a>00020 <span class="comment">//  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00021"></a>00021 <span class="comment">//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00022"></a>00022 <span class="comment">//  GNU General Public License for more details.</span>
<a name="l00023"></a>00023 <span class="comment">//</span>
<a name="l00024"></a>00024 <span class="comment">//  You should have received a copy of the GNU General Public License</span>
<a name="l00025"></a>00025 <span class="comment">//  along with this program; if not, write to the Free Software</span>
<a name="l00026"></a>00026 <span class="comment">//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.</span>
<a name="l00027"></a>00027 <span class="comment">//</span>
<a name="l00029"></a>00029 <span class="comment"></span>
<a name="l00030"></a>00030 <span class="preprocessor">#ifndef  SILHOUETTE_H</span>
<a name="l00031"></a>00031 <span class="preprocessor"></span><span class="preprocessor"># define SILHOUETTE_H</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span>
<a name="l00033"></a>00033 <span class="preprocessor"># include &lt;iostream&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor"># include &lt;string&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor"># include &lt;vector&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor"># include &lt;set&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor"># include &lt;float.h&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor"># include "../system/FreestyleConfig.h"</span>
<a name="l00039"></a>00039 <span class="preprocessor"># include "../geometry/Geom.h"</span>
<a name="l00040"></a>00040 <span class="preprocessor"># include "../geometry/BBox.h"</span>
<a name="l00041"></a>00041 <span class="preprocessor"># include "../scene_graph/Material.h"</span>
<a name="l00042"></a>00042 <span class="preprocessor"># include "../geometry/Polygon.h"</span>
<a name="l00043"></a>00043 <span class="preprocessor"># include "../system/Exception.h"</span>
<a name="l00044"></a>00044 <span class="preprocessor"># include "Interface0D.h"</span>
<a name="l00045"></a>00045 <span class="preprocessor"># include "<a class="code" href="Interface1D_8h.html">Interface1D.h</a>"</span>
<a name="l00046"></a>00046 <span class="preprocessor"># include "../winged_edge/Curvature.h"</span>
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 <span class="keyword">using namespace </span>std;
<a name="l00049"></a>00049 <span class="keyword">using namespace </span>Geometry;
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="keyword">class </span><a class="code" href="classViewShape.html">ViewShape</a>;
<a name="l00052"></a>00052 <span class="keyword">typedef</span> vector&lt;ViewShape*&gt; occluder_container;
<a name="l00053"></a>00053 
<a name="l00054"></a>00054                   <span class="comment">/**********************************/</span>
<a name="l00055"></a>00055                   <span class="comment">/*                                */</span>
<a name="l00056"></a>00056                   <span class="comment">/*                                */</span>
<a name="l00057"></a>00057                   <span class="comment">/*             SVertex            */</span>
<a name="l00058"></a>00058                   <span class="comment">/*                                */</span>
<a name="l00059"></a>00059                   <span class="comment">/*                                */</span>
<a name="l00060"></a>00060                   <span class="comment">/**********************************/</span>
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 <span class="keyword">class </span><a class="code" href="classFEdge.html">FEdge</a>;
<a name="l00063"></a>00063 <span class="keyword">class </span><a class="code" href="classViewVertex.html">ViewVertex</a>;
<a name="l00064"></a>00064 <span class="keyword">class </span><a class="code" href="classSShape.html">SShape</a>;
<a name="l00065"></a>00065 
<a name="l00067"></a><a class="code" href="classSVertex.html">00067</a> <span class="keyword">class </span>LIB_VIEW_MAP_EXPORT <a class="code" href="classSVertex.html">SVertex</a> : <span class="keyword">public</span> <a class="code" href="classInterface0D.html">Interface0D</a>
<a name="l00068"></a>00068 {
<a name="l00069"></a>00069 <span class="keyword">public</span>: <span class="comment">// Implementation of Interface0D</span>
<a name="l00070"></a>00070 
<a name="l00072"></a><a class="code" href="classSVertex.html#002b7eb8fd08613c974586b621ff2636">00072</a>   <span class="keyword">virtual</span> string <a class="code" href="classInterface0D.html#002b7eb8fd08613c974586b621ff2636">getExactTypeName</a>()<span class="keyword"> const </span>{
<a name="l00073"></a>00073     <span class="keywordflow">return</span> <span class="stringliteral">"SVertex"</span>;
<a name="l00074"></a>00074   }
<a name="l00075"></a>00075 
<a name="l00076"></a>00076   <span class="comment">// Data access methods</span>
<a name="l00077"></a>00077 
<a name="l00079"></a><a class="code" href="classSVertex.html#274823147ae3fafce59cbe9fb6dec08a">00079</a>   <span class="keyword">virtual</span> real <a class="code" href="classInterface0D.html#274823147ae3fafce59cbe9fb6dec08a">getX</a>()<span class="keyword"> const </span>{
<a name="l00080"></a>00080     <span class="keywordflow">return</span> _Point3D.x();
<a name="l00081"></a>00081   }
<a name="l00082"></a>00082 
<a name="l00084"></a><a class="code" href="classSVertex.html#f7e41b0ea9c10ae3bb6ffba615a82628">00084</a>   <span class="keyword">virtual</span> real <a class="code" href="classInterface0D.html#f7e41b0ea9c10ae3bb6ffba615a82628">getY</a>()<span class="keyword"> const </span>{
<a name="l00085"></a>00085     <span class="keywordflow">return</span> _Point3D.y();
<a name="l00086"></a>00086   }
<a name="l00087"></a>00087 
<a name="l00089"></a><a class="code" href="classSVertex.html#054421e6b566c6b515370982bbabbaef">00089</a>   <span class="keyword">virtual</span> real <a class="code" href="classInterface0D.html#054421e6b566c6b515370982bbabbaef">getZ</a>()<span class="keyword"> const </span>{
<a name="l00090"></a>00090     <span class="keywordflow">return</span> _Point3D.z();
<a name="l00091"></a>00091   }
<a name="l00092"></a>00092 
<a name="l00094"></a><a class="code" href="classSVertex.html#a63f0103f8f30be8036639e5d7cf25b4">00094</a>   <span class="keyword">virtual</span> Vec3f <a class="code" href="classInterface0D.html#4f6735c8455c5abc8ef0b6fcd47043df">getPoint3D</a>()<span class="keyword"> const </span>{
<a name="l00095"></a>00095     <span class="keywordflow">return</span> _Point3D;
<a name="l00096"></a>00096   }
<a name="l00097"></a>00097 
<a name="l00099"></a><a class="code" href="classSVertex.html#63f087d35a11d5c70d60ad8afec7643a">00099</a>   <span class="keyword">virtual</span> real <a class="code" href="classInterface0D.html#63f087d35a11d5c70d60ad8afec7643a">getProjectedX</a>()<span class="keyword"> const </span>{
<a name="l00100"></a>00100     <span class="keywordflow">return</span> _Point2D.x();
<a name="l00101"></a>00101   }
<a name="l00102"></a>00102 
<a name="l00104"></a><a class="code" href="classSVertex.html#d7dd5911b8a5c6631001e380fcc83b99">00104</a>   <span class="keyword">virtual</span> real <a class="code" href="classInterface0D.html#d7dd5911b8a5c6631001e380fcc83b99">getProjectedY</a>()<span class="keyword"> const </span>{
<a name="l00105"></a>00105     <span class="keywordflow">return</span> _Point2D.y();
<a name="l00106"></a>00106   }
<a name="l00107"></a>00107 
<a name="l00109"></a><a class="code" href="classSVertex.html#873f09cb4e7b1a4da69d7310686b57f0">00109</a>   <span class="keyword">virtual</span> real <a class="code" href="classInterface0D.html#873f09cb4e7b1a4da69d7310686b57f0">getProjectedZ</a>()<span class="keyword"> const </span>{
<a name="l00110"></a>00110     <span class="keywordflow">return</span> _Point2D.z();
<a name="l00111"></a>00111   }
<a name="l00112"></a>00112 
<a name="l00114"></a><a class="code" href="classSVertex.html#d1dd891e64a6b7c555bc0f7a6b61f809">00114</a>   <span class="keyword">virtual</span> Vec2f <a class="code" href="classInterface0D.html#387721134bb87d1fc375cd0416815e8d">getPoint2D</a>()<span class="keyword"> const </span>{
<a name="l00115"></a>00115     <span class="keywordflow">return</span> Vec2f((<span class="keywordtype">float</span>)_Point2D.x(),(float)_Point2D.y());
<a name="l00116"></a>00116   }
<a name="l00117"></a>00117 
<a name="l00120"></a>00120   <span class="keyword">virtual</span> <a class="code" href="classFEdge.html">FEdge</a>* <a class="code" href="classInterface0D.html#5d4c9028a3a06d36244654bc8b3df5ae">getFEdge</a>(<a class="code" href="classInterface0D.html">Interface0D</a>&amp;);
<a name="l00121"></a>00121 
<a name="l00123"></a><a class="code" href="classSVertex.html#67c9cf6326a694c4b411a2b32c90c56f">00123</a>   <span class="keyword">virtual</span> <a class="code" href="classId.html">Id</a> <a class="code" href="classInterface0D.html#67c9cf6326a694c4b411a2b32c90c56f">getId</a>()<span class="keyword"> const </span>{
<a name="l00124"></a>00124     <span class="keywordflow">return</span> _Id;
<a name="l00125"></a>00125   }
<a name="l00126"></a>00126 
<a name="l00128"></a>00128   <span class="keyword">virtual</span> Nature::VertexNature <a class="code" href="classInterface0D.html#643d426a4acc50f3a531e054ec8f5b42">getNature</a>() <span class="keyword">const</span>;
<a name="l00129"></a>00129 
<a name="l00131"></a>00131   <span class="keyword">virtual</span> <a class="code" href="classSVertex.html">SVertex</a> * <a class="code" href="classInterface0D.html#5a6b32ed4feeed6bcb90ae8b3549b347">castToSVertex</a>();
<a name="l00132"></a>00132 
<a name="l00134"></a>00134   <span class="keyword">virtual</span> <a class="code" href="classViewVertex.html">ViewVertex</a> * <a class="code" href="classInterface0D.html#a3037f6ca1e9a4d67b6b707e595db5d1">castToViewVertex</a>();
<a name="l00135"></a>00135 
<a name="l00137"></a>00137   <span class="keyword">virtual</span> <a class="code" href="classNonTVertex.html">NonTVertex</a> * <a class="code" href="classInterface0D.html#2e7defc35c0da9c275bbc2c0ed1e60e9">castToNonTVertex</a>();
<a name="l00138"></a>00138 
<a name="l00140"></a>00140   <span class="keyword">virtual</span> <a class="code" href="classTVertex.html">TVertex</a> * <a class="code" href="classInterface0D.html#d4f4e2d1e4a3f8cff0e67e8a4ec98996">castToTVertex</a>();
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 <span class="keyword">public</span>:
<a name="l00143"></a>00143 
<a name="l00144"></a>00144   <span class="keyword">typedef</span> vector&lt;FEdge*&gt; fedges_container;
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 <span class="keyword">private</span>:
<a name="l00147"></a>00147 
<a name="l00148"></a>00148   <a class="code" href="classId.html">Id</a> _Id;
<a name="l00149"></a>00149   Vec3r _Point3D;
<a name="l00150"></a>00150   Vec3r _Point2D;
<a name="l00151"></a>00151   set&lt;Vec3r&gt; _Normals; 
<a name="l00152"></a>00152   vector&lt;FEdge*&gt; _FEdges; <span class="comment">// the edges containing this vertex</span>
<a name="l00153"></a>00153   <a class="code" href="classSShape.html">SShape</a> *_Shape;  <span class="comment">// the shape to which belongs the vertex</span>
<a name="l00154"></a>00154   <a class="code" href="classViewVertex.html">ViewVertex</a> *_pViewVertex; <span class="comment">// The associated viewvertex, in case there is one.</span>
<a name="l00155"></a>00155   real _curvatureFredo;
<a name="l00156"></a>00156   Vec2r _directionFredo;
<a name="l00157"></a>00157   CurvatureInfo* _curvature_info;
<a name="l00158"></a>00158 
<a name="l00159"></a>00159 <span class="keyword">public</span>:
<a name="l00160"></a>00160 
<a name="l00164"></a><a class="code" href="classSVertex.html#fd0ffb02780e738d4c0a10ab833b7834">00164</a>   <span class="keywordtype">void</span> *userdata;
<a name="l00165"></a>00165 
<a name="l00167"></a><a class="code" href="classSVertex.html#41d3b615244312ab47a2a32b548f2e6b">00167</a>   <span class="keyword">inline</span> <a class="code" href="classSVertex.html">SVertex</a>() {
<a name="l00168"></a>00168     _Id = 0;
<a name="l00169"></a>00169     userdata = NULL;
<a name="l00170"></a>00170     _Shape = NULL;
<a name="l00171"></a>00171     _pViewVertex = 0;
<a name="l00172"></a>00172     _curvature_info = 0;
<a name="l00173"></a>00173   }
<a name="l00174"></a>00174 
<a name="l00176"></a><a class="code" href="classSVertex.html#d062f31dbc4609e9e00358d0632c5a9a">00176</a>   <span class="keyword">inline</span> <a class="code" href="classSVertex.html">SVertex</a>(<span class="keyword">const</span> Vec3r &amp;iPoint3D, <span class="keyword">const</span> <a class="code" href="classId.html">Id</a>&amp; <span class="keywordtype">id</span>) {
<a name="l00177"></a>00177     _Point3D = iPoint3D;
<a name="l00178"></a>00178     _Id=id;
<a name="l00179"></a>00179     userdata = NULL;
<a name="l00180"></a>00180     _Shape = NULL;
<a name="l00181"></a>00181     _pViewVertex=0;
<a name="l00182"></a>00182     _curvature_info = 0;
<a name="l00183"></a>00183   }
<a name="l00184"></a>00184 
<a name="l00186"></a><a class="code" href="classSVertex.html#4e521f98bf800e2a72bc3fd6225ff8a6">00186</a>   <span class="keyword">inline</span> <a class="code" href="classSVertex.html">SVertex</a>(<a class="code" href="classSVertex.html">SVertex</a>&amp; iBrother) {
<a name="l00187"></a>00187     _Id = iBrother.<a class="code" href="classSVertex.html#990bb362a91873746691d95a510b4acc">_Id</a>;
<a name="l00188"></a>00188     _Point3D =  iBrother.<a class="code" href="classSVertex.html#8f2ea75b6078ce295e8da77a4e919dab">point3D</a>();
<a name="l00189"></a>00189     _Point2D = iBrother.<a class="code" href="classSVertex.html#70626b19f52120aaef27d0feda776999">point2D</a>();
<a name="l00190"></a>00190     _Normals = iBrother.<a class="code" href="classSVertex.html#73315c3dd5aa9c562086d5a74c290d45">_Normals</a>;
<a name="l00191"></a>00191     _FEdges = iBrother.<a class="code" href="classSVertex.html#21184a6c2531d935096ce18a45be7cab">fedges</a>();
<a name="l00192"></a>00192     _Shape = iBrother.<a class="code" href="classSVertex.html#c9aad1d3bbb5a3a994f93c0e6b4b3635">shape</a>();
<a name="l00193"></a>00193     _pViewVertex = iBrother.<a class="code" href="classSVertex.html#e7a4ab3b80b81b3de175347c71a94840">_pViewVertex</a>;
<a name="l00194"></a>00194     <span class="keywordflow">if</span> (!(iBrother.<a class="code" href="classSVertex.html#8cb09ff8c7fbac45600107af594431ac">_curvature_info</a>))
<a name="l00195"></a>00195       _curvature_info = 0;
<a name="l00196"></a>00196     <span class="keywordflow">else</span>
<a name="l00197"></a>00197       _curvature_info = <span class="keyword">new</span> CurvatureInfo(*(iBrother.<a class="code" href="classSVertex.html#8cb09ff8c7fbac45600107af594431ac">_curvature_info</a>));
<a name="l00198"></a>00198     iBrother.<a class="code" href="classSVertex.html#fd0ffb02780e738d4c0a10ab833b7834">userdata</a> = <span class="keyword">this</span>;
<a name="l00199"></a>00199     userdata = 0;
<a name="l00200"></a>00200   }
<a name="l00201"></a>00201 
<a name="l00203"></a><a class="code" href="classSVertex.html#d4171f18b6ac604af6cdbcdac3d2e248">00203</a>   <span class="keyword">virtual</span> ~<a class="code" href="classSVertex.html">SVertex</a>() {
<a name="l00204"></a>00204     <span class="keywordflow">if</span> (_curvature_info)
<a name="l00205"></a>00205       <span class="keyword">delete</span> _curvature_info;
<a name="l00206"></a>00206   }
<a name="l00207"></a>00207 
<a name="l00209"></a><a class="code" href="classSVertex.html#69dc404218289d3531f99b36b42dc2bc">00209</a>   <span class="keyword">virtual</span> <a class="code" href="classSVertex.html">SVertex</a> * dupplicate() {
<a name="l00210"></a>00210     <a class="code" href="classSVertex.html">SVertex</a> *clone = <span class="keyword">new</span> <a class="code" href="classSVertex.html">SVertex</a>(*<span class="keyword">this</span>);
<a name="l00211"></a>00211     <span class="keywordflow">return</span> clone;
<a name="l00212"></a>00212   }
<a name="l00213"></a>00213 
<a name="l00215"></a><a class="code" href="classSVertex.html#5f7f63f1a98ff99d7d64c48f891fa31d">00215</a>   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> <a class="code" href="classSVertex.html">SVertex</a>&amp; iBrother) {
<a name="l00216"></a>00216     <span class="keywordflow">return</span> ((_Point2D == iBrother.<a class="code" href="classSVertex.html#c615617ccb64bf779bf61fbc0d80eca4">_Point2D</a>) &amp;&amp;
<a name="l00217"></a>00217             (_Point3D == iBrother.<a class="code" href="classSVertex.html#4907007130c6e688d90a83b2674ca079">_Point3D</a>));
<a name="l00218"></a>00218   }
<a name="l00219"></a>00219 
<a name="l00220"></a>00220   <span class="comment">/* accessors */</span>
<a name="l00221"></a>00221   <span class="keyword">inline</span> <span class="keyword">const</span> Vec3r&amp; point3D()<span class="keyword"> const </span>{<span class="keywordflow">return</span> _Point3D;}
<a name="l00222"></a>00222   <span class="keyword">inline</span> <span class="keyword">const</span> Vec3r&amp; point2D()<span class="keyword"> const </span>{<span class="keywordflow">return</span> _Point2D;}
<a name="l00227"></a><a class="code" href="classSVertex.html#6f34bc494db4b1976297d668a11a9116">00227</a>   <span class="keyword">inline</span> set&lt;Vec3r&gt; normals() {<span class="keywordflow">return</span> _Normals;}
<a name="l00229"></a><a class="code" href="classSVertex.html#0376350f54dbafe9b4ad646c80e0c0f3">00229</a>   <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> normalsSize()<span class="keyword"> const </span>{<span class="keywordflow">return</span> _Normals.size();}
<a name="l00230"></a>00230   <span class="keyword">inline</span> <span class="keyword">const</span> vector&lt;FEdge*&gt;&amp; fedges() {<span class="keywordflow">return</span> _FEdges;}
<a name="l00231"></a>00231   <span class="keyword">inline</span> fedges_container::iterator fedges_begin() {<span class="keywordflow">return</span> _FEdges.begin();}
<a name="l00232"></a>00232   <span class="keyword">inline</span> fedges_container::iterator fedges_end() {<span class="keywordflow">return</span> _FEdges.end();}
<a name="l00233"></a>00233   <span class="keyword">inline</span> <a class="code" href="classSShape.html">SShape</a> * shape() {<span class="keywordflow">return</span> _Shape;}
<a name="l00234"></a>00234   <span class="keyword">inline</span> real z()<span class="keyword"> const </span>{<span class="keywordflow">return</span> _Point2D[2];}
<a name="l00239"></a><a class="code" href="classSVertex.html#146eab5fabe63f146727535fcc35383b">00239</a>   <span class="keyword">inline</span> <a class="code" href="classViewVertex.html">ViewVertex</a> * viewvertex() {<span class="keywordflow">return</span> _pViewVertex;}
<a name="l00240"></a>00240 
<a name="l00243"></a><a class="code" href="classSVertex.html#c52098d1b02c9028dd2b5121cd460229">00243</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> SetPoint3D(<span class="keyword">const</span> Vec3r &amp;iPoint3D) {_Point3D = iPoint3D;}
<a name="l00245"></a><a class="code" href="classSVertex.html#7ca3d9f8cc735e13352078739e207c0a">00245</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> SetPoint2D(<span class="keyword">const</span> Vec3r &amp;iPoint2D) {_Point2D = iPoint2D;}
<a name="l00249"></a><a class="code" href="classSVertex.html#95e7d2011767e95b18a6e44a3c2e729a">00249</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> AddNormal(<span class="keyword">const</span> Vec3r&amp; iNormal) 
<a name="l00250"></a>00250   {
<a name="l00251"></a>00251     _Normals.insert(iNormal); <span class="comment">// if iNormal in the set already exists, nothing is done</span>
<a name="l00252"></a>00252   }
<a name="l00253"></a>00253 
<a name="l00254"></a>00254   <span class="keywordtype">void</span> setCurvatureInfo(CurvatureInfo* ci) {
<a name="l00255"></a>00255     _curvature_info = ci;
<a name="l00256"></a>00256   }
<a name="l00257"></a>00257 
<a name="l00258"></a>00258   <span class="keyword">const</span> CurvatureInfo* getCurvatureInfo()<span class="keyword"> const </span>{
<a name="l00259"></a>00259     <span class="keywordflow">return</span> _curvature_info;
<a name="l00260"></a>00260   }
<a name="l00261"></a>00261 
<a name="l00262"></a>00262   <span class="comment">/* Fredo's normal and curvature*/</span>
<a name="l00263"></a>00263   <span class="keywordtype">void</span> setCurvatureFredo(real c) {_curvatureFredo=c;}
<a name="l00264"></a>00264   <span class="keywordtype">void</span> setDirectionFredo(Vec2r d) {_directionFredo=d;}
<a name="l00265"></a>00265   real curvatureFredo () {<span class="keywordflow">return</span> _curvatureFredo;}
<a name="l00266"></a>00266   <span class="keyword">const</span> Vec2r directionFredo () {<span class="keywordflow">return</span> _directionFredo;}
<a name="l00267"></a>00267 
<a name="l00269"></a><a class="code" href="classSVertex.html#6d8d9b7436118c053c323a4367d70424">00269</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> SetId(<span class="keyword">const</span> <a class="code" href="classId.html">Id</a>&amp; <span class="keywordtype">id</span>) {_Id = id;}
<a name="l00270"></a>00270   <span class="keyword">inline</span> <span class="keywordtype">void</span> SetFEdges(<span class="keyword">const</span> vector&lt;FEdge*&gt;&amp; iFEdges) {_FEdges = iFEdges;}
<a name="l00271"></a>00271   <span class="keyword">inline</span> <span class="keywordtype">void</span> SetShape(<a class="code" href="classSShape.html">SShape</a> *iShape) {_Shape = iShape;}
<a name="l00272"></a>00272   <span class="keyword">inline</span> <span class="keywordtype">void</span> SetViewVertex(<a class="code" href="classViewVertex.html">ViewVertex</a> *iViewVertex) {_pViewVertex = iViewVertex;}
<a name="l00274"></a><a class="code" href="classSVertex.html#d1576a51272a82f8c2a924f0d2021939">00274</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> AddFEdge(<a class="code" href="classFEdge.html">FEdge</a>* iFEdge) {_FEdges.push_back(iFEdge);}
<a name="l00275"></a>00275   <span class="comment">/* replaces edge 1 by edge 2 in the list of edges */</span>
<a name="l00276"></a>00276   <span class="keyword">inline</span> <span class="keywordtype">void</span> Replace(<a class="code" href="classFEdge.html">FEdge</a> *e1, <a class="code" href="classFEdge.html">FEdge</a> *e2)
<a name="l00277"></a>00277   {
<a name="l00278"></a>00278     vector&lt;FEdge*&gt;::iterator insertedfe;
<a name="l00279"></a>00279     <span class="keywordflow">for</span>(vector&lt;FEdge*&gt;::iterator fe=_FEdges.begin(),fend=_FEdges.end();
<a name="l00280"></a>00280         fe!=fend;
<a name="l00281"></a>00281         fe++)
<a name="l00282"></a>00282       {
<a name="l00283"></a>00283         <span class="keywordflow">if</span>((*fe) == e1)
<a name="l00284"></a>00284           {
<a name="l00285"></a>00285             insertedfe = _FEdges.insert(fe, e2);<span class="comment">// inserts e2 before fe.</span>
<a name="l00286"></a>00286                                                 <span class="comment">// returns an iterator pointing toward e2. fe is invalidated.</span>
<a name="l00287"></a>00287             <span class="comment">// we want to remove e1, but we can't use fe anymore:</span>
<a name="l00288"></a>00288             insertedfe++; <span class="comment">// insertedfe points now to e1</span>
<a name="l00289"></a>00289             _FEdges.erase(insertedfe);
<a name="l00290"></a>00290             <span class="keywordflow">return</span>;
<a name="l00291"></a>00291           }
<a name="l00292"></a>00292       }
<a name="l00293"></a>00293   }
<a name="l00294"></a>00294 
<a name="l00295"></a>00295 <span class="keyword">public</span>:
<a name="l00296"></a>00296 
<a name="l00297"></a>00297   <span class="comment">/* Information access interface */</span>
<a name="l00298"></a>00298 
<a name="l00299"></a>00299   <a class="code" href="classFEdge.html">FEdge</a> *fedge() ; <span class="comment">// for non T vertex</span>
<a name="l00300"></a>00300   <span class="keyword">inline</span> <span class="keyword">const</span> Vec3r&amp; point2d()<span class="keyword"> const </span>{<span class="keywordflow">return</span> point2D();}
<a name="l00301"></a>00301   <span class="keyword">inline</span> <span class="keyword">const</span> Vec3r&amp; point3d()<span class="keyword"> const </span>{<span class="keywordflow">return</span> point3D();}
<a name="l00302"></a>00302   <span class="keyword">inline</span> Vec3r normal()<span class="keyword"> const </span>{<span class="keywordflow">if</span>(_Normals.size() == 1) <span class="keywordflow">return</span> (*(_Normals.begin())); Exception::raiseException(); <span class="keywordflow">return</span> *(_Normals.begin());}
<a name="l00303"></a>00303   <span class="comment">//Material material() const ;</span>
<a name="l00304"></a>00304   <a class="code" href="classId.html">Id</a> shape_id() <span class="keyword">const </span>;
<a name="l00305"></a>00305   <span class="keyword">const</span> <a class="code" href="classSShape.html">SShape</a>* shape() <span class="keyword">const </span>;
<a name="l00306"></a>00306   <span class="keywordtype">float</span> shape_importance() <span class="keyword">const </span>;
<a name="l00307"></a>00307   
<a name="l00308"></a>00308   <span class="keyword">const</span> <span class="keywordtype">int</span> qi() <span class="keyword">const </span>;
<a name="l00309"></a>00309   occluder_container::const_iterator occluders_begin() <span class="keyword">const </span>;
<a name="l00310"></a>00310   occluder_container::const_iterator occluders_end() <span class="keyword">const </span>;
<a name="l00311"></a>00311   <span class="keywordtype">bool</span> occluders_empty() <span class="keyword">const </span>;
<a name="l00312"></a>00312   <span class="keywordtype">int</span> occluders_size() <span class="keyword">const </span>;
<a name="l00313"></a>00313   <span class="keyword">const</span> Polygon3r&amp; occludee() <span class="keyword">const </span>;
<a name="l00314"></a>00314   <span class="keyword">const</span> <a class="code" href="classSShape.html">SShape</a> * occluded_shape() <span class="keyword">const </span>;
<a name="l00315"></a>00315   <span class="keyword">const</span> <span class="keywordtype">bool</span>  occludee_empty() <span class="keyword">const </span>;
<a name="l00316"></a>00316   real z_discontinuity() <span class="keyword">const </span>;
<a name="l00317"></a>00317   <span class="comment">//inline float local_average_depth() const ;</span>
<a name="l00318"></a>00318   <span class="comment">//  inline float local_depth_variance() const ;</span>
<a name="l00319"></a>00319   <span class="comment">//  inline real local_average_density(float sigma = 2.3f) const ;</span>
<a name="l00320"></a>00320   <span class="comment">//inline Vec3r shaded_color() const ;</span>
<a name="l00321"></a>00321   <span class="comment">//  inline Vec3r orientation2d() const ; </span>
<a name="l00322"></a>00322   <span class="comment">//  inline Vec3r orientation3d() const ;</span>
<a name="l00323"></a>00323   <span class="comment">//  inline Vec3r curvature2d_as_vector() const ;</span>
<a name="l00325"></a>00325 <span class="comment"></span>  <span class="comment">//  inline real curvature2d_as_angle() const ;</span>
<a name="l00326"></a>00326   
<a name="l00327"></a>00327 };
<a name="l00328"></a>00328 
<a name="l00329"></a>00329                   <span class="comment">/**********************************/</span>
<a name="l00330"></a>00330                   <span class="comment">/*                                */</span>
<a name="l00331"></a>00331                   <span class="comment">/*                                */</span>
<a name="l00332"></a>00332                   <span class="comment">/*             FEdge              */</span>
<a name="l00333"></a>00333                   <span class="comment">/*                                */</span>
<a name="l00334"></a>00334                   <span class="comment">/*                                */</span>
<a name="l00335"></a>00335                   <span class="comment">/**********************************/</span>
<a name="l00336"></a>00336 
<a name="l00337"></a>00337 
<a name="l00338"></a>00338 <span class="keyword">class </span><a class="code" href="classViewEdge.html">ViewEdge</a>;
<a name="l00353"></a><a class="code" href="classFEdge.html">00353</a> <span class="keyword">class </span>LIB_VIEW_MAP_EXPORT FEdge : <span class="keyword">public</span> <a class="code" href="classInterface1D.html">Interface1D</a>
<a name="l00354"></a>00354 {
<a name="l00355"></a>00355 <span class="keyword">public</span>: <span class="comment">// Implementation of Interface0D</span>
<a name="l00356"></a>00356 
<a name="l00358"></a><a class="code" href="classFEdge.html#002b7eb8fd08613c974586b621ff2636">00358</a>   <span class="keyword">virtual</span> string <a class="code" href="classInterface1D.html#002b7eb8fd08613c974586b621ff2636">getExactTypeName</a>()<span class="keyword"> const </span>{
<a name="l00359"></a>00359     <span class="keywordflow">return</span> <span class="stringliteral">"FEdge"</span>;
<a name="l00360"></a>00360   }
<a name="l00361"></a>00361 
<a name="l00362"></a>00362   <span class="comment">// Data access methods</span>
<a name="l00363"></a>00363 
<a name="l00365"></a><a class="code" href="classFEdge.html#de0358cc652d27bcf526cbe9e527ff0d">00365</a>   <span class="keyword">virtual</span> real <a class="code" href="classInterface1D.html#de0358cc652d27bcf526cbe9e527ff0d">getLength2D</a>()<span class="keyword"> const </span>{
<a name="l00366"></a>00366     <span class="keywordflow">if</span> (!_VertexA || !_VertexB)
<a name="l00367"></a>00367       <span class="keywordflow">return</span> 0;
<a name="l00368"></a>00368     <span class="keywordflow">return</span> (_VertexB-&gt;getPoint2D() - _VertexA-&gt;getPoint2D()).norm();
<a name="l00369"></a>00369   }
<a name="l00370"></a>00370 
<a name="l00372"></a><a class="code" href="classFEdge.html#67c9cf6326a694c4b411a2b32c90c56f">00372</a>   <span class="keyword">virtual</span> <a class="code" href="classId.html">Id</a> <a class="code" href="classInterface1D.html#67c9cf6326a694c4b411a2b32c90c56f">getId</a>()<span class="keyword"> const </span>{
<a name="l00373"></a>00373     <span class="keywordflow">return</span> _Id;
<a name="l00374"></a>00374   }
<a name="l00375"></a>00375 
<a name="l00376"></a>00376 <span class="keyword">public</span>:
<a name="l00377"></a>00377 
<a name="l00378"></a>00378   <span class="comment">// An edge can only be of one kind (SILHOUETTE or BORDER, etc...)</span>
<a name="l00379"></a>00379   <span class="comment">// For an multi-nature edge there must be several different FEdge.</span>
<a name="l00380"></a>00380    <span class="comment">// DEBUG:</span>
<a name="l00381"></a>00381   <span class="comment">//  Vec3r A;</span>
<a name="l00382"></a>00382   <span class="comment">//  Vec3r u;</span>
<a name="l00383"></a>00383   <span class="comment">//  vector&lt;Polygon3r&gt; _Occludees;</span>
<a name="l00384"></a>00384   <span class="comment">//  Vec3r intersection;</span>
<a name="l00385"></a>00385   <span class="comment">//  vector&lt;Vec3i&gt; _Cells;</span>
<a name="l00386"></a>00386 
<a name="l00387"></a>00387 <span class="keyword">protected</span>:
<a name="l00388"></a>00388   <a class="code" href="classSVertex.html">SVertex</a> *_VertexA;
<a name="l00389"></a>00389   <a class="code" href="classSVertex.html">SVertex</a> *_VertexB;
<a name="l00390"></a>00390   <a class="code" href="classId.html">Id</a> _Id;
<a name="l00391"></a>00391   Nature::EdgeNature _Nature;
<a name="l00392"></a>00392   <span class="comment">//vector&lt;Polygon3r&gt; _Occluders; // visibility // NON GERE PAR LE COPY CONSTRUCTOR!!</span>
<a name="l00393"></a>00393   
<a name="l00394"></a>00394   FEdge *_NextEdge; <span class="comment">// next edge on the chain</span>
<a name="l00395"></a>00395   FEdge *_PreviousEdge;
<a name="l00396"></a>00396   <a class="code" href="classViewEdge.html">ViewEdge</a> *_ViewEdge;
<a name="l00397"></a>00397   <span class="comment">// Sometimes we need to deport the visibility computation onto another </span>
<a name="l00398"></a>00398   <span class="comment">// edge. For example the exact edges use edges of the mesh to </span>
<a name="l00399"></a>00399   <span class="comment">// compute their visibility</span>
<a name="l00400"></a>00400   
<a name="l00401"></a>00401   Polygon3r _aFace; <span class="comment">// The occluded face which lies on the right of a silhouette edge</span>
<a name="l00402"></a>00402   Vec3r _occludeeIntersection;
<a name="l00403"></a>00403   <span class="keywordtype">bool</span> _occludeeEmpty;
<a name="l00404"></a>00404 
<a name="l00405"></a>00405   <span class="keywordtype">bool</span> _isSmooth;
<a name="l00406"></a>00406 
<a name="l00407"></a>00407 <span class="keyword">public</span>:
<a name="l00411"></a><a class="code" href="classFEdge.html#fd0ffb02780e738d4c0a10ab833b7834">00411</a>   <span class="keywordtype">void</span> *userdata;
<a name="l00413"></a><a class="code" href="classFEdge.html#45db62ee2708a183c3dc7595cc45fc9d">00413</a>   <span class="keyword">inline</span> FEdge() {
<a name="l00414"></a>00414     userdata = NULL;
<a name="l00415"></a>00415     _Nature = Nature::NO_FEATURE;
<a name="l00416"></a>00416     _NextEdge = NULL;
<a name="l00417"></a>00417     _PreviousEdge = NULL;
<a name="l00418"></a>00418     _ViewEdge = NULL;
<a name="l00419"></a>00419     <span class="comment">//_hasVisibilityPoint=false;</span>
<a name="l00420"></a>00420     _occludeeEmpty = <span class="keyword">true</span>;
<a name="l00421"></a>00421     _isSmooth = <span class="keyword">false</span>;
<a name="l00422"></a>00422   }
<a name="l00424"></a><a class="code" href="classFEdge.html#58580f2c9c940c1a8b5aa792104b1a96">00424</a>   <span class="keyword">inline</span> FEdge(<a class="code" href="classSVertex.html">SVertex</a> *vA, <a class="code" href="classSVertex.html">SVertex</a> *vB) {
<a name="l00425"></a>00425     userdata = NULL;
<a name="l00426"></a>00426     _VertexA = vA;
<a name="l00427"></a>00427     _VertexB = vB;
<a name="l00428"></a>00428     _Nature = Nature::NO_FEATURE;
<a name="l00429"></a>00429     _NextEdge=NULL;
<a name="l00430"></a>00430     _PreviousEdge=NULL;
<a name="l00431"></a>00431     _ViewEdge = NULL;
<a name="l00432"></a>00432     <span class="comment">//_hasVisibilityPoint=false;</span>
<a name="l00433"></a>00433     _occludeeEmpty = <span class="keyword">true</span>;
<a name="l00434"></a>00434     _isSmooth = <span class="keyword">false</span>;
<a name="l00435"></a>00435   }
<a name="l00437"></a><a class="code" href="classFEdge.html#ecca463b2b7da6c11a1a51573d6b534d">00437</a>   <span class="keyword">inline</span> FEdge(FEdge&amp; iBrother)
<a name="l00438"></a>00438   {
<a name="l00439"></a>00439     _VertexA = iBrother.<a class="code" href="classFEdge.html#93fffa48a5ca729a446882b6fe99edba">vertexA</a>();
<a name="l00440"></a>00440     _VertexB = iBrother.<a class="code" href="classFEdge.html#00458b207b0cc7ae45f26f158088b0b1">vertexB</a>();
<a name="l00441"></a>00441     _NextEdge = iBrother.<a class="code" href="classFEdge.html#0f051f7f2d16c5abc6a91e0602d4841e">nextEdge</a>();
<a name="l00442"></a>00442     _PreviousEdge = iBrother.<a class="code" href="classFEdge.html#71eaf19dfcea5dca262b3dd29de1465c">_PreviousEdge</a>;
<a name="l00443"></a>00443     _Nature = iBrother.<a class="code" href="classFEdge.html#58a18b3ad438cbaf7fa2dc5c1dacc4c7">getNature</a>();
<a name="l00444"></a>00444     _Id = iBrother.<a class="code" href="classFEdge.html#990bb362a91873746691d95a510b4acc">_Id</a>;
<a name="l00445"></a>00445     _ViewEdge = iBrother.<a class="code" href="classFEdge.html#18e2a4c15b57fa7f4dbf7c59a24914e6">_ViewEdge</a>;
<a name="l00446"></a>00446     <span class="comment">//_hasVisibilityPoint = iBrother._hasVisibilityPoint;</span>
<a name="l00447"></a>00447     <span class="comment">//_VisibilityPointA = iBrother._VisibilityPointA;</span>
<a name="l00448"></a>00448     <span class="comment">//_VisibilityPointB = iBrother._VisibilityPointB;</span>
<a name="l00449"></a>00449     _aFace = iBrother.<a class="code" href="classFEdge.html#733c9f192fe543f979854b40fc0425ef">_aFace</a>;
<a name="l00450"></a>00450     _occludeeEmpty = iBrother.<a class="code" href="classFEdge.html#2bdb2177c4b894b6c870d7a3f0514533">_occludeeEmpty</a>;
<a name="l00451"></a>00451     _isSmooth = iBrother.<a class="code" href="classFEdge.html#9eecf0ff879413ea3d51cd6d6c48ffbf">_isSmooth</a>;
<a name="l00452"></a>00452     iBrother.<a class="code" href="classFEdge.html#fd0ffb02780e738d4c0a10ab833b7834">userdata</a> = <span class="keyword">this</span>;
<a name="l00453"></a>00453     userdata = 0;
<a name="l00454"></a>00454   }
<a name="l00456"></a><a class="code" href="classFEdge.html#9c9a65b2c7c0e97d05f71ace52965b65">00456</a>   <span class="keyword">virtual</span> ~FEdge() {}
<a name="l00458"></a><a class="code" href="classFEdge.html#a5dc9e8eeee0db96b9cf5992e9a793c4">00458</a>   <span class="keyword">virtual</span> FEdge* dupplicate()
<a name="l00459"></a>00459   {
<a name="l00460"></a>00460     FEdge *clone = <span class="keyword">new</span> FEdge(*<span class="keyword">this</span>);
<a name="l00461"></a>00461     <span class="keywordflow">return</span> clone;
<a name="l00462"></a>00462   }
<a name="l00463"></a>00463   <span class="comment">/* accessors */</span>
<a name="l00465"></a><a class="code" href="classFEdge.html#93fffa48a5ca729a446882b6fe99edba">00465</a>   <span class="keyword">inline</span> <a class="code" href="classSVertex.html">SVertex</a>* vertexA() {<span class="keywordflow">return</span> _VertexA;}
<a name="l00467"></a><a class="code" href="classFEdge.html#00458b207b0cc7ae45f26f158088b0b1">00467</a>   <span class="keyword">inline</span> <a class="code" href="classSVertex.html">SVertex</a>* vertexB() {<span class="keywordflow">return</span> _VertexB;}
<a name="l00470"></a><a class="code" href="classFEdge.html#294e2aefad335516405997a4012f4515">00470</a>   <span class="keyword">inline</span> <a class="code" href="classSVertex.html">SVertex</a>* operator[](<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <span class="keywordtype">int</span>&amp; i)<span class="keyword"> const</span>{ 
<a name="l00471"></a>00471       <span class="keywordflow">return</span> i%2==0 ? _VertexA : _VertexB;
<a name="l00472"></a>00472   }
<a name="l00474"></a><a class="code" href="classFEdge.html#58a18b3ad438cbaf7fa2dc5c1dacc4c7">00474</a>   <span class="keyword">inline</span> Nature::EdgeNature <a class="code" href="classInterface1D.html#4e9afa184b4cabf5b83e9422de62170f">getNature</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> _Nature;}
<a name="l00478"></a><a class="code" href="classFEdge.html#0f051f7f2d16c5abc6a91e0602d4841e">00478</a>   <span class="keyword">inline</span> FEdge * nextEdge() {<span class="keywordflow">return</span> _NextEdge;}
<a name="l00482"></a><a class="code" href="classFEdge.html#13f90355a566cc4059c39a0d18bf6030">00482</a>   <span class="keyword">inline</span> FEdge * previousEdge() {<span class="keywordflow">return</span> _PreviousEdge;}
<a name="l00483"></a>00483   <span class="keyword">inline</span> <a class="code" href="classSShape.html">SShape</a> * shape() {<span class="keywordflow">return</span> _VertexA-&gt;shape();}
<a name="l00484"></a>00484   <span class="comment">//inline int invisibility() const {return _Occluders.size();}</span>
<a name="l00485"></a>00485   <span class="keywordtype">int</span> invisibility() <span class="keyword">const </span>;
<a name="l00486"></a>00486   <span class="comment">//inline const vector&lt;Polygon3r&gt;&amp; occluders() const {return _Occluders;}</span>
<a name="l00488"></a><a class="code" href="classFEdge.html#3eb81c258f1eb2e2d903dc0d1b8e3b66">00488</a> <span class="comment"></span>  <span class="keyword">inline</span> <a class="code" href="classViewEdge.html">ViewEdge</a> * viewedge()<span class="keyword"> const </span>{<span class="keywordflow">return</span> _ViewEdge;}
<a name="l00489"></a>00489   <span class="keyword">inline</span> Vec3r center3d() {<span class="keywordflow">return</span> Vec3r((_VertexA-&gt;point3D()+_VertexB-&gt;point3D())/2.0);}
<a name="l00490"></a>00490   <span class="keyword">inline</span> Vec3r center2d() {<span class="keywordflow">return</span> Vec3r((_VertexA-&gt;point2D()+_VertexB-&gt;point2D())/2.0);}
<a name="l00491"></a>00491   <span class="comment">//  inline bool hasVisibilityPoint() const {return _hasVisibilityPoint;}</span>
<a name="l00492"></a>00492   <span class="comment">//  inline Vec3r visibilityPointA() const {return _VisibilityPointA;}</span>
<a name="l00493"></a>00493   <span class="comment">//  inline Vec3r visibilityPointB() const {return _VisibilityPointB;}</span>
<a name="l00494"></a>00494   <span class="keyword">inline</span> <span class="keyword">const</span> Polygon3r&amp; aFace()<span class="keyword"> const </span>{<span class="keywordflow">return</span> _aFace;}
<a name="l00495"></a>00495   <span class="keyword">inline</span> <span class="keyword">const</span> Vec3r&amp; getOccludeeIntersection() { <span class="keywordflow">return</span> _occludeeIntersection; }
<a name="l00496"></a>00496   <span class="keyword">inline</span> <span class="keywordtype">bool</span> getOccludeeEmpty() { <span class="keywordflow">return</span> _occludeeEmpty; }
<a name="l00498"></a><a class="code" href="classFEdge.html#4d53d5a77fdef5ea5a7b610d10572b58">00498</a>   <span class="keyword">inline</span> <span class="keywordtype">bool</span> isSmooth()<span class="keyword"> const </span>{<span class="keywordflow">return</span> _isSmooth;}
<a name="l00499"></a>00499 
<a name="l00500"></a>00500   <span class="comment">/* modifiers */</span>
<a name="l00502"></a><a class="code" href="classFEdge.html#f2b08c60affce43d36ed39b32ba4142f">00502</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> SetVertexA(<a class="code" href="classSVertex.html">SVertex</a> *vA) {_VertexA = vA;}
<a name="l00504"></a><a class="code" href="classFEdge.html#e1f131a94dcf1c9f24260bf3c14b6ee4">00504</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> SetVertexB(<a class="code" href="classSVertex.html">SVertex</a> *vB) {_VertexB = vB;}
<a name="l00506"></a><a class="code" href="classFEdge.html#6d8d9b7436118c053c323a4367d70424">00506</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> SetId(<span class="keyword">const</span> <a class="code" href="classId.html">Id</a>&amp; <span class="keywordtype">id</span>) {_Id = id;}
<a name="l00508"></a><a class="code" href="classFEdge.html#180be4be13b1b0af4dee10093ab5f295">00508</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> SetNextEdge(FEdge* iEdge) {_NextEdge = iEdge;}
<a name="l00510"></a><a class="code" href="classFEdge.html#db927ea9d5f86cda05f96c393f2ff4be">00510</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> SetPreviousEdge(FEdge *iEdge) {_PreviousEdge = iEdge;}
<a name="l00512"></a><a class="code" href="classFEdge.html#30304d45ddff3272a7496efab801dd83">00512</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> SetNature(Nature::EdgeNature iNature) {_Nature = iNature;}
<a name="l00513"></a>00513   <span class="comment">//inline void AddOccluder(Polygon3r&amp; iPolygon) {_Occluders.push_back(iPolygon);}</span>
<a name="l00515"></a><a class="code" href="classFEdge.html#91acf5439e8eae7b557605d364d803ae">00515</a> <span class="comment"></span>  <span class="keyword">inline</span> <span class="keywordtype">void</span> SetViewEdge(<a class="code" href="classViewEdge.html">ViewEdge</a> *iViewEdge) {_ViewEdge = iViewEdge;}
<a name="l00516"></a>00516   <span class="comment">//  inline void SetHasVisibilityPoint(bool iBool) {_hasVisibilityPoint = iBool;}</span>
<a name="l00517"></a>00517   <span class="comment">//  inline void SetVisibilityPointA(const Vec3r&amp; iPoint) {_VisibilityPointA = iPoint;}</span>
<a name="l00518"></a>00518   <span class="comment">//  inline void SetVisibilityPointB(const Vec3r&amp; iPoint) {_VisibilityPointB = iPoint;}</span>
<a name="l00519"></a>00519   <span class="keyword">inline</span> <span class="keywordtype">void</span> SetaFace(Polygon3r&amp; iFace) {_aFace = iFace;}
<a name="l00520"></a>00520   <span class="keyword">inline</span> <span class="keywordtype">void</span> SetOccludeeIntersection(<span class="keyword">const</span> Vec3r&amp; iPoint) {_occludeeIntersection = iPoint;}
<a name="l00521"></a>00521   <span class="keyword">inline</span> <span class="keywordtype">void</span> SetOccludeeEmpty(<span class="keywordtype">bool</span> iempty) {_occludeeEmpty = iempty;}
<a name="l00525"></a><a class="code" href="classFEdge.html#41c777edc2497b74be696873f627fba0">00525</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> SetSmooth(<span class="keywordtype">bool</span> iFlag) {_isSmooth = iFlag;}
<a name="l00526"></a>00526   
<a name="l00527"></a>00527   <span class="comment">/* checks whether two FEdge have a common vertex.</span>
<a name="l00528"></a>00528 <span class="comment">   *  Returns a pointer on the common vertex if it exists, </span>
<a name="l00529"></a>00529 <span class="comment">   *  NULL otherwise.</span>
<a name="l00530"></a>00530 <span class="comment">   */</span>
<a name="l00531"></a>00531   <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="classSVertex.html">SVertex</a>* CommonVertex(FEdge *iEdge1, FEdge* iEdge2)
<a name="l00532"></a>00532   {
<a name="l00533"></a>00533     <span class="keywordflow">if</span>((NULL == iEdge1) || (NULL == iEdge2))
<a name="l00534"></a>00534       <span class="keywordflow">return</span> NULL;
<a name="l00535"></a>00535 
<a name="l00536"></a>00536     <a class="code" href="classSVertex.html">SVertex</a> *sv1 = iEdge1-&gt;<a class="code" href="classFEdge.html#93fffa48a5ca729a446882b6fe99edba">vertexA</a>();
<a name="l00537"></a>00537     <a class="code" href="classSVertex.html">SVertex</a> *sv2 = iEdge1-&gt;<a class="code" href="classFEdge.html#00458b207b0cc7ae45f26f158088b0b1">vertexB</a>();
<a name="l00538"></a>00538     <a class="code" href="classSVertex.html">SVertex</a> *sv3 = iEdge2-&gt;<a class="code" href="classFEdge.html#93fffa48a5ca729a446882b6fe99edba">vertexA</a>();
<a name="l00539"></a>00539     <a class="code" href="classSVertex.html">SVertex</a> *sv4 = iEdge2-&gt;<a class="code" href="classFEdge.html#00458b207b0cc7ae45f26f158088b0b1">vertexB</a>();
<a name="l00540"></a>00540 
<a name="l00541"></a>00541     <span class="keywordflow">if</span>((sv1 == sv3) || (sv1 == sv4))
<a name="l00542"></a>00542     {
<a name="l00543"></a>00543       <span class="keywordflow">return</span> sv1;
<a name="l00544"></a>00544     }
<a name="l00545"></a>00545     <span class="keywordflow">else</span> <span class="keywordflow">if</span>((sv2 == sv3) || (sv2 == sv4))
<a name="l00546"></a>00546     {
<a name="l00547"></a>00547       <span class="keywordflow">return</span> sv2;
<a name="l00548"></a>00548     }
<a name="l00549"></a>00549 
<a name="l00550"></a>00550     <span class="keywordflow">return</span> NULL;
<a name="l00551"></a>00551   }
<a name="l00552"></a>00552 
<a name="l00553"></a>00553   <span class="keyword">inline</span> <span class="keyword">const</span> <a class="code" href="classSVertex.html">SVertex</a>* min2d()<span class="keyword"> const </span>
<a name="l00554"></a>00554 <span class="keyword">  </span>{
<a name="l00555"></a>00555     <span class="keywordflow">if</span>(_VertexA-&gt;point2D() &lt; _VertexB-&gt;point2D())
<a name="l00556"></a>00556       <span class="keywordflow">return</span> _VertexA;
<a name="l00557"></a>00557     <span class="keywordflow">else</span>
<a name="l00558"></a>00558       <span class="keywordflow">return</span> _VertexB;
<a name="l00559"></a>00559   }
<a name="l00560"></a>00560   <span class="keyword">inline</span> <span class="keyword">const</span> <a class="code" href="classSVertex.html">SVertex</a>* max2d()<span class="keyword"> const </span>
<a name="l00561"></a>00561 <span class="keyword">  </span>{
<a name="l00562"></a>00562     <span class="keywordflow">if</span>(_VertexA-&gt;point2D() &lt; _VertexB-&gt;point2D())
<a name="l00563"></a>00563       <span class="keywordflow">return</span> _VertexB;
<a name="l00564"></a>00564     <span class="keywordflow">else</span>
<a name="l00565"></a>00565       <span class="keywordflow">return</span> _VertexA;
<a name="l00566"></a>00566   }
<a name="l00567"></a>00567  
<a name="l00568"></a>00568   <span class="comment">/* Information access interface */</span>
<a name="l00569"></a>00569   <span class="comment">/* Information access interface */</span>
<a name="l00570"></a>00570  
<a name="l00571"></a>00571   <span class="comment">//Material material() const ;</span>
<a name="l00572"></a>00572   <a class="code" href="classId.html">Id</a> shape_id() <span class="keyword">const </span>;
<a name="l00573"></a>00573   <span class="keyword">const</span> <a class="code" href="classSShape.html">SShape</a> * shape() <span class="keyword">const </span>;
<a name="l00574"></a>00574   <span class="keywordtype">float</span> shape_importance() <span class="keyword">const </span>;
<a name="l00575"></a>00575   <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">int</span> qi()<span class="keyword"> const </span>{<span class="keywordflow">return</span> invisibility();}
<a name="l00576"></a>00576   occluder_container::const_iterator occluders_begin() <span class="keyword">const </span>;
<a name="l00577"></a>00577   occluder_container::const_iterator occluders_end() <span class="keyword">const </span>;
<a name="l00578"></a>00578   <span class="keywordtype">bool</span> occluders_empty() <span class="keyword">const </span>;
<a name="l00579"></a>00579   <span class="keywordtype">int</span> occluders_size() <span class="keyword">const </span>;
<a name="l00580"></a>00580   <span class="keyword">inline</span> <span class="keyword">const</span> Polygon3r&amp; occludee()<span class="keyword"> const </span>{<span class="keywordflow">return</span> aFace();}
<a name="l00581"></a>00581   <span class="keyword">const</span> <a class="code" href="classSShape.html">SShape</a> * occluded_shape() <span class="keyword">const </span>;
<a name="l00582"></a>00582   <span class="comment">//inline const bool  occludee_empty() const {return _occludeeEmpty;}</span>
<a name="l00583"></a>00583   <span class="keyword">const</span> <span class="keywordtype">bool</span>  occludee_empty() <span class="keyword">const </span>;
<a name="l00584"></a>00584   real z_discontinuity() <span class="keyword">const </span>;
<a name="l00585"></a>00585   <span class="comment">//  inline float local_average_depth(int iCombination = 0) const ;</span>
<a name="l00586"></a>00586   <span class="comment">//  inline float local_depth_variance(int iCombination = 0) const ;</span>
<a name="l00587"></a>00587   <span class="comment">//  inline real local_average_density(float sigma = 2.3f, int iCombination = 0) const ;</span>
<a name="l00588"></a>00588   <span class="comment">//inline Vec3r shaded_color(int iCombination = 0) const {}</span>
<a name="l00589"></a>00589   <span class="keywordtype">int</span> viewedge_nature() <span class="keyword">const </span>;
<a name="l00590"></a>00590   <span class="comment">//float viewedge_length() const ;</span>
<a name="l00591"></a>00591   <span class="keyword">inline</span> Vec3r orientation2d()<span class="keyword"> const </span>{<span class="keywordflow">return</span> Vec3r(_VertexB-&gt;point2d()-_VertexA-&gt;point2d());}
<a name="l00592"></a>00592   <span class="keyword">inline</span> Vec3r orientation3d()<span class="keyword"> const </span>{<span class="keywordflow">return</span> Vec3r(_VertexB-&gt;point3d()-_VertexA-&gt;point3d());}
<a name="l00593"></a>00593   <span class="comment">//  //inline real curvature2d() const {return viewedge()-&gt;curvature2d((_VertexA-&gt;point2d()+_VertexB-&gt;point2d())/2.0);}</span>
<a name="l00594"></a>00594   <span class="comment">//  inline Vec3r curvature2d_as_vector(int iCombination = 0) const ;</span>
<a name="l00595"></a>00595   <span class="comment">//  /* angle in degrees*/</span>
<a name="l00596"></a>00596   <span class="comment">//  inline real curvature2d_as_angle(int iCombination = 0) const ;  </span>
<a name="l00597"></a>00597 
<a name="l00598"></a>00598 
<a name="l00599"></a>00599   <span class="comment">// Iterator access (Interface1D)</span>
<a name="l00602"></a>00602 <span class="comment"></span>  <span class="keyword">virtual</span> <span class="keyword">inline</span> <a class="code" href="classInterface0DIterator.html">Interface0DIterator</a> <a class="code" href="classInterface1D.html#4458730e2155c35c1b1fa4c311a2ae84">verticesBegin</a>();
<a name="l00605"></a>00605   <span class="keyword">virtual</span> <span class="keyword">inline</span> <a class="code" href="classInterface0DIterator.html">Interface0DIterator</a> <a class="code" href="classInterface1D.html#98056338b56441646f2603d7bd9cec6a">verticesEnd</a>();
<a name="l00606"></a>00606 
<a name="l00616"></a>00616   <span class="keyword">virtual</span> <span class="keyword">inline</span> <a class="code" href="classInterface0DIterator.html">Interface0DIterator</a> <a class="code" href="classInterface1D.html#86c0dbd5aa633652033069a7b577d83e">pointsBegin</a>(<span class="keywordtype">float</span> t=0.f);
<a name="l00626"></a>00626   <span class="keyword">virtual</span> <span class="keyword">inline</span> <a class="code" href="classInterface0DIterator.html">Interface0DIterator</a> <a class="code" href="classInterface1D.html#a935b2752a0817c97414824ff355fbfc">pointsEnd</a>(<span class="keywordtype">float</span> t=0.f);
<a name="l00627"></a>00627 };
<a name="l00628"></a>00628 
<a name="l00629"></a>00629 <span class="comment">//</span>
<a name="l00630"></a>00630 <span class="comment">// SVertexIterator</span>
<a name="l00631"></a>00631 <span class="comment">//</span>
<a name="l00633"></a>00633 <span class="comment"></span>
<a name="l00634"></a>00634 <span class="keyword">namespace </span>FEdgeInternal {
<a name="l00635"></a>00635 
<a name="l00636"></a>00636   <span class="keyword">class </span>SVertexIterator : <span class="keyword">public</span> Interface0DIteratorNested
<a name="l00637"></a>00637   {
<a name="l00638"></a>00638   <span class="keyword">public</span>:
<a name="l00639"></a>00639 
<a name="l00640"></a>00640     SVertexIterator() {
<a name="l00641"></a>00641       _vertex = NULL;
<a name="l00642"></a>00642       _edge = NULL;
<a name="l00643"></a>00643     }
<a name="l00644"></a>00644 
<a name="l00645"></a>00645     SVertexIterator(<span class="keyword">const</span> SVertexIterator&amp; vi) {
<a name="l00646"></a>00646       _vertex = vi._vertex;
<a name="l00647"></a>00647       _edge = vi._edge;
<a name="l00648"></a>00648     }
<a name="l00649"></a>00649 
<a name="l00650"></a>00650     SVertexIterator(<a class="code" href="classSVertex.html">SVertex</a>* v, FEdge* edge) {
<a name="l00651"></a>00651       _vertex = v;
<a name="l00652"></a>00652       _edge = edge;
<a name="l00653"></a>00653     }
<a name="l00654"></a>00654 
<a name="l00655"></a>00655     SVertexIterator&amp; operator=(<span class="keyword">const</span> SVertexIterator&amp; vi) {
<a name="l00656"></a>00656       _vertex = vi._vertex;
<a name="l00657"></a>00657       _edge = vi._edge;
<a name="l00658"></a>00658       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00659"></a>00659     }
<a name="l00660"></a>00660 
<a name="l00661"></a>00661     <span class="keyword">virtual</span> string getExactTypeName()<span class="keyword"> const </span>{
<a name="l00662"></a>00662       <span class="keywordflow">return</span> <span class="stringliteral">"SVertexIterator"</span>;
<a name="l00663"></a>00663     }
<a name="l00664"></a>00664 
<a name="l00665"></a>00665     <span class="keyword">virtual</span> <a class="code" href="classSVertex.html">SVertex</a>&amp; operator*() {
<a name="l00666"></a>00666       <span class="keywordflow">return</span> *_vertex;
<a name="l00667"></a>00667     }
<a name="l00668"></a>00668 
<a name="l00669"></a>00669     <span class="keyword">virtual</span> <a class="code" href="classSVertex.html">SVertex</a>* operator-&gt;() {
<a name="l00670"></a>00670       <span class="keywordflow">return</span> &amp;(operator*());
<a name="l00671"></a>00671     }
<a name="l00672"></a>00672 
<a name="l00673"></a>00673     <span class="keyword">virtual</span> SVertexIterator&amp; operator++() {
<a name="l00674"></a>00674       increment();
<a name="l00675"></a>00675       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00676"></a>00676     }
<a name="l00677"></a>00677 
<a name="l00678"></a>00678     <span class="keyword">virtual</span> SVertexIterator operator++(<span class="keywordtype">int</span>) {
<a name="l00679"></a>00679       SVertexIterator ret(*<span class="keyword">this</span>);
<a name="l00680"></a>00680       increment();
<a name="l00681"></a>00681       <span class="keywordflow">return</span> ret;
<a name="l00682"></a>00682     }
<a name="l00683"></a>00683 
<a name="l00684"></a>00684     <span class="keyword">virtual</span> SVertexIterator&amp; operator--() {
<a name="l00685"></a>00685       decrement();
<a name="l00686"></a>00686       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00687"></a>00687     }
<a name="l00688"></a>00688 
<a name="l00689"></a>00689     <span class="keyword">virtual</span> SVertexIterator operator--(<span class="keywordtype">int</span>) {
<a name="l00690"></a>00690       SVertexIterator ret(*<span class="keyword">this</span>);
<a name="l00691"></a>00691       decrement();
<a name="l00692"></a>00692       <span class="keywordflow">return</span> ret;
<a name="l00693"></a>00693     }
<a name="l00694"></a>00694 
<a name="l00695"></a>00695     <span class="keyword">virtual</span> <span class="keywordtype">void</span> increment() {
<a name="l00696"></a>00696       <span class="keywordflow">if</span> (_vertex == _edge-&gt;vertexB()) {
<a name="l00697"></a>00697         _vertex = 0;
<a name="l00698"></a>00698         <span class="keywordflow">return</span>;
<a name="l00699"></a>00699       }
<a name="l00700"></a>00700 
<a name="l00701"></a>00701       _vertex = _edge-&gt;vertexB();
<a name="l00702"></a>00702     }
<a name="l00703"></a>00703 
<a name="l00704"></a>00704     <span class="keyword">virtual</span> <span class="keywordtype">void</span> decrement() {
<a name="l00705"></a>00705       <span class="keywordflow">if</span> (_vertex == _edge-&gt;vertexA()) {
<a name="l00706"></a>00706         _vertex = 0;
<a name="l00707"></a>00707         <span class="keywordflow">return</span>;
<a name="l00708"></a>00708       }
<a name="l00709"></a>00709       _vertex = _edge-&gt;vertexA();
<a name="l00710"></a>00710     }
<a name="l00711"></a>00711 
<a name="l00712"></a>00712     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> isBegin()<span class="keyword"> const </span>{
<a name="l00713"></a>00713       <span class="keywordflow">return</span> _vertex == _edge-&gt;vertexA();
<a name="l00714"></a>00714     }
<a name="l00715"></a>00715 
<a name="l00716"></a>00716     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> isEnd()<span class="keyword"> const </span>{
<a name="l00717"></a>00717       <span class="keywordflow">return</span> _vertex == _edge-&gt;vertexB();
<a name="l00718"></a>00718     }
<a name="l00719"></a>00719 
<a name="l00720"></a>00720     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> Interface0DIteratorNested&amp; it)<span class="keyword"> const </span>{
<a name="l00721"></a>00721       <span class="keyword">const</span> SVertexIterator* it_exact = dynamic_cast&lt;const SVertexIterator*&gt;(&amp;it);
<a name="l00722"></a>00722       <span class="keywordflow">if</span> (!it_exact)
<a name="l00723"></a>00723         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00724"></a>00724       <span class="keywordflow">return</span> ((_vertex == it_exact-&gt;_vertex) &amp;&amp;
<a name="l00725"></a>00725               (_edge == it_exact-&gt;_edge));
<a name="l00726"></a>00726     }
<a name="l00727"></a>00727 
<a name="l00728"></a>00728     <span class="keyword">virtual</span> <span class="keywordtype">float</span> t()<span class="keyword"> const</span>{
<a name="l00729"></a>00729       <span class="keywordflow">if</span>(_vertex == _edge-&gt;vertexA()){
<a name="l00730"></a>00730         <span class="keywordflow">return</span> 0;
<a name="l00731"></a>00731       }
<a name="l00732"></a>00732       <span class="keywordflow">return</span> ((<span class="keywordtype">float</span>)_edge-&gt;getLength2D());
<a name="l00733"></a>00733     }
<a name="l00734"></a>00734     <span class="keyword">virtual</span> <span class="keywordtype">float</span> u()<span class="keyword"> const</span>{
<a name="l00735"></a>00735       <span class="keywordflow">if</span>(_vertex == _edge-&gt;vertexA()){
<a name="l00736"></a>00736         <span class="keywordflow">return</span> 0;
<a name="l00737"></a>00737       }
<a name="l00738"></a>00738       <span class="keywordflow">return</span> 1.0;
<a name="l00739"></a>00739     }
<a name="l00740"></a>00740     <span class="keyword">virtual</span> SVertexIterator* copy()<span class="keyword"> const </span>{
<a name="l00741"></a>00741       <span class="keywordflow">return</span> <span class="keyword">new</span> SVertexIterator(*<span class="keyword">this</span>);
<a name="l00742"></a>00742     }
<a name="l00743"></a>00743 
<a name="l00744"></a>00744   <span class="keyword">private</span>:
<a name="l00745"></a>00745 
<a name="l00746"></a>00746     <a class="code" href="classSVertex.html">SVertex</a>*    _vertex;
<a name="l00747"></a>00747     FEdge*      _edge;
<a name="l00748"></a>00748   };
<a name="l00749"></a>00749 
<a name="l00750"></a>00750 } <span class="comment">// end of namespace FEdgeInternal</span>
<a name="l00751"></a>00751 
<a name="l00752"></a>00752 <span class="comment">// Iterator access (implementation)</span>
<a name="l00753"></a>00753 
<a name="l00754"></a><a class="code" href="classFEdge.html#0628b3170d571dbd02183eff236ba53e">00754</a> <a class="code" href="classInterface0DIterator.html">Interface0DIterator</a> <a class="code" href="classFEdge.html#0628b3170d571dbd02183eff236ba53e">FEdge::verticesBegin</a>() {
<a name="l00755"></a>00755   <a class="code" href="classInterface0DIterator.html">Interface0DIterator</a> ret(<span class="keyword">new</span> FEdgeInternal::SVertexIterator(_VertexA, <span class="keyword">this</span>));
<a name="l00756"></a>00756   <span class="keywordflow">return</span> ret;
<a name="l00757"></a>00757 }
<a name="l00758"></a>00758 
<a name="l00759"></a><a class="code" href="classFEdge.html#f9a3b1472af5996c5e6a90d0ae03349c">00759</a> <a class="code" href="classInterface0DIterator.html">Interface0DIterator</a> <a class="code" href="classFEdge.html#f9a3b1472af5996c5e6a90d0ae03349c">FEdge::verticesEnd</a>() {
<a name="l00760"></a>00760   <a class="code" href="classInterface0DIterator.html">Interface0DIterator</a> ret(<span class="keyword">new</span> FEdgeInternal::SVertexIterator(0, <span class="keyword">this</span>));
<a name="l00761"></a>00761   <span class="keywordflow">return</span> ret;
<a name="l00762"></a>00762 }
<a name="l00763"></a>00763 
<a name="l00764"></a><a class="code" href="classFEdge.html#a9b3bce9b99fba5f094ea0bca80636ad">00764</a> <a class="code" href="classInterface0DIterator.html">Interface0DIterator</a> <a class="code" href="classFEdge.html#a9b3bce9b99fba5f094ea0bca80636ad">FEdge::pointsBegin</a>(<span class="keywordtype">float</span> t) {
<a name="l00765"></a>00765   <span class="keywordflow">return</span> <a class="code" href="classFEdge.html#0628b3170d571dbd02183eff236ba53e">verticesBegin</a>();
<a name="l00766"></a>00766 }
<a name="l00767"></a>00767 
<a name="l00768"></a><a class="code" href="classFEdge.html#a043fdb7927dbc5d7419dc50d0e112cf">00768</a> <a class="code" href="classInterface0DIterator.html">Interface0DIterator</a> <a class="code" href="classFEdge.html#a043fdb7927dbc5d7419dc50d0e112cf">FEdge::pointsEnd</a>(<span class="keywordtype">float</span> t) {
<a name="l00769"></a>00769   <span class="keywordflow">return</span> <a class="code" href="classFEdge.html#f9a3b1472af5996c5e6a90d0ae03349c">verticesEnd</a>();
<a name="l00770"></a>00770 }
<a name="l00771"></a>00771 
<a name="l00781"></a><a class="code" href="classFEdgeSharp.html">00781</a> <span class="keyword">class </span>LIB_VIEW_MAP_EXPORT FEdgeSharp : <span class="keyword">public</span> FEdge
<a name="l00782"></a>00782 {
<a name="l00783"></a>00783 <span class="keyword">protected</span>:
<a name="l00784"></a>00784   Vec3r _aNormal; <span class="comment">// When following the edge, normal of the right face</span>
<a name="l00785"></a>00785   Vec3r _bNormal; <span class="comment">// When following the edge, normal of the left face</span>
<a name="l00786"></a>00786   <span class="keywordtype">unsigned</span> _aMaterialIndex;
<a name="l00787"></a>00787   <span class="keywordtype">unsigned</span> _bMaterialIndex;
<a name="l00788"></a>00788   
<a name="l00789"></a>00789 <span class="keyword">public</span>:
<a name="l00791"></a><a class="code" href="classFEdgeSharp.html#6ad1690604e8ddf5887c9b50d434ed75">00791</a>   <span class="keyword">inline</span> FEdgeSharp() : FEdge(){
<a name="l00792"></a>00792     _aMaterialIndex = _bMaterialIndex = 0;
<a name="l00793"></a>00793   }
<a name="l00795"></a><a class="code" href="classFEdgeSharp.html#aa546286fb1db6b0671eb8347397ceda">00795</a>   <span class="keyword">inline</span> FEdgeSharp(<a class="code" href="classSVertex.html">SVertex</a> *vA, <a class="code" href="classSVertex.html">SVertex</a> *vB) : FEdge(vA, vB){
<a name="l00796"></a>00796     _aMaterialIndex = _bMaterialIndex = 0;
<a name="l00797"></a>00797   }
<a name="l00799"></a><a class="code" href="classFEdgeSharp.html#ee3ce7a2b2f0fd171232530e14431b90">00799</a>   <span class="keyword">inline</span> FEdgeSharp(FEdgeSharp&amp; iBrother) : FEdge(iBrother){
<a name="l00800"></a>00800     _aNormal = iBrother.<a class="code" href="classFEdgeSharp.html#56fa069aec1c016b1ed5e3a217968724">_aNormal</a>;
<a name="l00801"></a>00801     _bNormal = iBrother.<a class="code" href="classFEdgeSharp.html#79b48f3df9301a5809ea8b1f662049c3">_bNormal</a>;
<a name="l00802"></a>00802     _aMaterialIndex = iBrother.<a class="code" href="classFEdgeSharp.html#73ec385e7298a8c57ff725a6942b5e71">_aMaterialIndex</a>;
<a name="l00803"></a>00803     _bMaterialIndex = iBrother.<a class="code" href="classFEdgeSharp.html#126719cc5a69fb6464a271853c72be65">_bMaterialIndex</a>;
<a name="l00804"></a>00804   }
<a name="l00806"></a><a class="code" href="classFEdgeSharp.html#93f8a1380cd69294de1b222ec46edc8b">00806</a>   <span class="keyword">virtual</span> ~FEdgeSharp() {}
<a name="l00808"></a><a class="code" href="classFEdgeSharp.html#a5dc9e8eeee0db96b9cf5992e9a793c4">00808</a>   <span class="keyword">virtual</span> FEdge* <a class="code" href="classFEdge.html#a5dc9e8eeee0db96b9cf5992e9a793c4">dupplicate</a>(){
<a name="l00809"></a>00809     FEdge *clone = <span class="keyword">new</span> FEdgeSharp(*<span class="keyword">this</span>);
<a name="l00810"></a>00810     <span class="keywordflow">return</span> clone;
<a name="l00811"></a>00811   }
<a name="l00816"></a><a class="code" href="classFEdgeSharp.html#8246525029f2d8206b3aba29a5f8e82c">00816</a>   <span class="keyword">inline</span> <span class="keyword">const</span> Vec3r&amp; normalA() {<span class="keywordflow">return</span> _aNormal;}
<a name="l00820"></a><a class="code" href="classFEdgeSharp.html#fd3fb32de3ac07aac37871cdb9e0c4ee">00820</a>   <span class="keyword">inline</span> <span class="keyword">const</span> Vec3r&amp; normalB() {<span class="keywordflow">return</span> _bNormal;}
<a name="l00825"></a><a class="code" href="classFEdgeSharp.html#7fb0836d61d7dc3d40ee46d358c9ceff">00825</a>   <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> aMaterialIndex()<span class="keyword"> const </span>{<span class="keywordflow">return</span> _aMaterialIndex;}
<a name="l00830"></a>00830   <span class="keyword">const</span> <a class="code" href="classMaterial.html">Material</a>&amp; aMaterial() <span class="keyword">const </span>;
<a name="l00834"></a><a class="code" href="classFEdgeSharp.html#1aa8b440b38507f677474ee018357b37">00834</a>   <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> bMaterialIndex()<span class="keyword"> const </span>{<span class="keywordflow">return</span> _bMaterialIndex;}
<a name="l00838"></a>00838   <span class="keyword">const</span> <a class="code" href="classMaterial.html">Material</a>&amp; bMaterial() <span class="keyword">const </span>;
<a name="l00839"></a>00839 
<a name="l00841"></a><a class="code" href="classFEdgeSharp.html#ff774476d53d243734558fe633ff59f8">00841</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> SetNormalA(<span class="keyword">const</span> Vec3r&amp; iNormal) {_aNormal = iNormal;}
<a name="l00843"></a><a class="code" href="classFEdgeSharp.html#0d3bebf65b382add603feb1e02f4b355">00843</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> SetNormalB(<span class="keyword">const</span> Vec3r&amp; iNormal) {_bNormal = iNormal;}
<a name="l00845"></a><a class="code" href="classFEdgeSharp.html#1d636c91b555379af06f05b55b64ca6c">00845</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> SetaMaterialIndex(<span class="keywordtype">unsigned</span> i) {_aMaterialIndex = i;}
<a name="l00847"></a><a class="code" href="classFEdgeSharp.html#38eb9d2d517d74e63184ef11762f46c9">00847</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> SetbMaterialIndex(<span class="keywordtype">unsigned</span> i) {_bMaterialIndex = i;}
<a name="l00848"></a>00848   
<a name="l00849"></a>00849 };
<a name="l00850"></a>00850 
<a name="l00855"></a><a class="code" href="classFEdgeSmooth.html">00855</a> <span class="keyword">class </span>LIB_VIEW_MAP_EXPORT FEdgeSmooth : <span class="keyword">public</span> FEdge
<a name="l00856"></a>00856 {
<a name="l00857"></a>00857 <span class="keyword">protected</span>:
<a name="l00858"></a>00858   Vec3r _Normal;
<a name="l00859"></a>00859   <span class="keywordtype">unsigned</span> _MaterialIndex;
<a name="l00860"></a>00860   <span class="comment">//  bool _hasVisibilityPoint;</span>
<a name="l00861"></a>00861   <span class="comment">//  Vec3r _VisibilityPointA;  // The edge on which the visibility will be computed represented </span>
<a name="l00862"></a>00862   <span class="comment">//  Vec3r _VisibilityPointB;  // using its 2 extremity points A and B</span>
<a name="l00863"></a>00863   <span class="keywordtype">void</span> * _Face; <span class="comment">// In case of exact silhouette, Face is the WFace crossed by Fedge </span>
<a name="l00864"></a>00864                <span class="comment">// NON GERE PAR LE COPY CONSTRUCTEUR</span>
<a name="l00865"></a>00865 <span class="keyword">public</span>:
<a name="l00867"></a><a class="code" href="classFEdgeSmooth.html#80d99ed954be40ef34053c82965b3375">00867</a>   <span class="keyword">inline</span> FEdgeSmooth() : FEdge(){
<a name="l00868"></a>00868     _Face=0;
<a name="l00869"></a>00869     _MaterialIndex = 0;
<a name="l00870"></a>00870     _isSmooth = <span class="keyword">true</span>;
<a name="l00871"></a>00871   }
<a name="l00873"></a><a class="code" href="classFEdgeSmooth.html#ed318ce40559b1e276a9099a05c7c48d">00873</a>   <span class="keyword">inline</span> FEdgeSmooth(<a class="code" href="classSVertex.html">SVertex</a> *vA, <a class="code" href="classSVertex.html">SVertex</a> *vB) : FEdge(vA, vB){
<a name="l00874"></a>00874     _Face=0;
<a name="l00875"></a>00875     _MaterialIndex = 0;
<a name="l00876"></a>00876     _isSmooth = <span class="keyword">true</span>;
<a name="l00877"></a>00877 
<a name="l00878"></a>00878   }
<a name="l00880"></a><a class="code" href="classFEdgeSmooth.html#28966df63dee300aa03327fdce6ca0ad">00880</a>   <span class="keyword">inline</span> FEdgeSmooth(FEdgeSmooth&amp; iBrother) : FEdge(iBrother){
<a name="l00881"></a>00881     _Normal = iBrother.<a class="code" href="classFEdgeSmooth.html#21f676d1c5a0d6ee627df8a50e593ab6">_Normal</a>;
<a name="l00882"></a>00882     _Face = iBrother.<a class="code" href="classFEdgeSmooth.html#3aa651d79a0d590a42a937fb8a012e08">_Face</a>;
<a name="l00883"></a>00883     _MaterialIndex = iBrother.<a class="code" href="classFEdgeSmooth.html#431749f43f5241bf12c6bc6cf08f57ed">_MaterialIndex</a>;
<a name="l00884"></a>00884     _isSmooth = <span class="keyword">true</span>;
<a name="l00885"></a>00885   }
<a name="l00887"></a><a class="code" href="classFEdgeSmooth.html#30261ed30a48312013b24d2b4227b69c">00887</a>   <span class="keyword">virtual</span> ~FEdgeSmooth() {}
<a name="l00889"></a><a class="code" href="classFEdgeSmooth.html#a5dc9e8eeee0db96b9cf5992e9a793c4">00889</a>   <span class="keyword">virtual</span> FEdge* <a class="code" href="classFEdge.html#a5dc9e8eeee0db96b9cf5992e9a793c4">dupplicate</a>(){
<a name="l00890"></a>00890     FEdge *clone = <span class="keyword">new</span> FEdgeSmooth(*<span class="keyword">this</span>);
<a name="l00891"></a>00891     <span class="keywordflow">return</span> clone;
<a name="l00892"></a>00892   }
<a name="l00893"></a>00893 
<a name="l00894"></a>00894   <span class="keyword">inline</span> <span class="keywordtype">void</span> * face()<span class="keyword"> const </span>{<span class="keywordflow">return</span> _Face;}
<a name="l00896"></a><a class="code" href="classFEdgeSmooth.html#f0848c2d4455a72c7f0d4a15248f41e0">00896</a>   <span class="keyword">inline</span> <span class="keyword">const</span> Vec3r&amp; normal() {<span class="keywordflow">return</span> _Normal;}
<a name="l00898"></a><a class="code" href="classFEdgeSmooth.html#ee8388946e6a28ae70aec1648c3203e1">00898</a>   <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> materialIndex()<span class="keyword"> const </span>{<span class="keywordflow">return</span> _MaterialIndex;}
<a name="l00900"></a>00900   <span class="keyword">const</span> <a class="code" href="classMaterial.html">Material</a>&amp; material() <span class="keyword">const </span>;
<a name="l00901"></a>00901 
<a name="l00902"></a>00902   <span class="keyword">inline</span> <span class="keywordtype">void</span> SetFace(<span class="keywordtype">void</span> * iFace) {_Face = iFace;}
<a name="l00904"></a><a class="code" href="classFEdgeSmooth.html#575962be97a1e7da1114172fa27bd7c4">00904</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> SetNormal(<span class="keyword">const</span> Vec3r&amp; iNormal) {_Normal = iNormal;}
<a name="l00906"></a><a class="code" href="classFEdgeSmooth.html#9dbf9495fe51b1c78cb6c742cbe64f98">00906</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> SetMaterialIndex(<span class="keywordtype">unsigned</span> i) {_MaterialIndex = i;}
<a name="l00907"></a>00907 };
<a name="l00908"></a>00908                   <span class="comment">/**********************************/</span>
<a name="l00909"></a>00909                   <span class="comment">/*                                */</span>
<a name="l00910"></a>00910                   <span class="comment">/*                                */</span>
<a name="l00911"></a>00911                   <span class="comment">/*             SShape             */</span>
<a name="l00912"></a>00912                   <span class="comment">/*                                */</span>
<a name="l00913"></a>00913                   <span class="comment">/*                                */</span>
<a name="l00914"></a>00914                   <span class="comment">/**********************************/</span>
<a name="l00915"></a>00915 
<a name="l00916"></a>00916 
<a name="l00920"></a><a class="code" href="classSShape.html">00920</a> <span class="keyword">class </span>LIB_VIEW_MAP_EXPORT SShape
<a name="l00921"></a>00921 {
<a name="l00922"></a>00922 <span class="keyword">private</span>:
<a name="l00923"></a>00923   vector&lt;FEdge*&gt; _chains;          <span class="comment">// list of fedges that are chains starting points.</span>
<a name="l00924"></a>00924   vector&lt;SVertex*&gt; _verticesList;  <span class="comment">// list of all vertices</span>
<a name="l00925"></a>00925   vector&lt;FEdge*&gt;   _edgesList;     <span class="comment">// list of all edges</span>
<a name="l00926"></a>00926   <a class="code" href="classId.html">Id</a> _Id;
<a name="l00927"></a>00927   BBox&lt;Vec3r&gt; _BBox;
<a name="l00928"></a>00928   vector&lt;Material&gt; _Materials;  
<a name="l00929"></a>00929 
<a name="l00930"></a>00930   <span class="keywordtype">float</span> _importance;
<a name="l00931"></a>00931 
<a name="l00932"></a>00932   <a class="code" href="classViewShape.html">ViewShape</a> *_ViewShape;
<a name="l00933"></a>00933 
<a name="l00934"></a>00934 <span class="keyword">public</span>:
<a name="l00938"></a><a class="code" href="classSShape.html#fd0ffb02780e738d4c0a10ab833b7834">00938</a>   <span class="keywordtype">void</span>* userdata; <span class="comment">// added by E.T.</span>
<a name="l00940"></a><a class="code" href="classSShape.html#96203d21ced1df0f7855713a5d2f15bc">00940</a> <span class="comment"></span>  <span class="keyword">inline</span> SShape()
<a name="l00941"></a>00941   {
<a name="l00942"></a>00942     userdata = 0;
<a name="l00943"></a>00943 
<a name="l00944"></a>00944     _importance = 0.f;
<a name="l00945"></a>00945     _ViewShape = 0;
<a name="l00946"></a>00946   }
<a name="l00948"></a><a class="code" href="classSShape.html#7efbc7428e12ccbab021466bae0974e3">00948</a>   <span class="keyword">inline</span> SShape(SShape&amp; iBrother)
<a name="l00949"></a>00949   {
<a name="l00950"></a>00950     userdata = 0;
<a name="l00951"></a>00951     _Id = iBrother.<a class="code" href="classSShape.html#990bb362a91873746691d95a510b4acc">_Id</a>;
<a name="l00952"></a>00952     _BBox = iBrother.<a class="code" href="classSShape.html#274a7765c3404fb632708ac0b6dd0e87">bbox</a>();
<a name="l00953"></a>00953     _Materials = iBrother.<a class="code" href="classSShape.html#92d6f67baf3043b3cf3166dc7af5ed68">_Materials</a>;
<a name="l00954"></a>00954 
<a name="l00955"></a>00955     _importance = iBrother.<a class="code" href="classSShape.html#7c17dbc96e9529d44e39c8bf84d599d4">_importance</a>;
<a name="l00956"></a>00956 
<a name="l00957"></a>00957     _ViewShape = iBrother.<a class="code" href="classSShape.html#afc579d5e445d920642243ed2dfcf0fa">_ViewShape</a>;
<a name="l00958"></a>00958 
<a name="l00959"></a>00959      
<a name="l00960"></a>00960     <span class="comment">//---------</span>
<a name="l00961"></a>00961     <span class="comment">// vertices</span>
<a name="l00962"></a>00962     <span class="comment">//---------</span>
<a name="l00963"></a>00963     vector&lt;SVertex*&gt;::iterator sv,svend;
<a name="l00964"></a>00964     vector&lt;SVertex*&gt;&amp; verticesList = iBrother.<a class="code" href="classSShape.html#fa2f4ec84de6ae0b01abec8c0c8233c5">GetVertexList</a>();
<a name="l00965"></a>00965     <span class="keywordflow">for</span>(sv=verticesList.begin(), svend=verticesList.end();
<a name="l00966"></a>00966         sv!=svend;
<a name="l00967"></a>00967         sv++)
<a name="l00968"></a>00968       {
<a name="l00969"></a>00969         <a class="code" href="classSVertex.html">SVertex</a> *newv = <span class="keyword">new</span> <a class="code" href="classSVertex.html">SVertex</a>(*(*sv));
<a name="l00970"></a>00970         newv-&gt;SetShape(<span class="keyword">this</span>);
<a name="l00971"></a>00971         _verticesList.push_back(newv);
<a name="l00972"></a>00972       }
<a name="l00973"></a>00973     
<a name="l00974"></a>00974     <span class="comment">//------</span>
<a name="l00975"></a>00975     <span class="comment">// edges</span>
<a name="l00976"></a>00976     <span class="comment">//------</span>
<a name="l00977"></a>00977     vector&lt;FEdge*&gt;::iterator e,eend;
<a name="l00978"></a>00978     vector&lt;FEdge*&gt;&amp; edgesList = iBrother.<a class="code" href="classSShape.html#1f3a5553b32168c566948cf4085ec4e7">GetEdgeList</a>();
<a name="l00979"></a>00979     <span class="keywordflow">for</span>(e=edgesList.begin(),eend=edgesList.end();
<a name="l00980"></a>00980         e!=eend;
<a name="l00981"></a>00981         e++)
<a name="l00982"></a>00982       {
<a name="l00983"></a>00983         FEdge *newe = (*e)-&gt;dupplicate();
<a name="l00984"></a>00984         _edgesList.push_back(newe);
<a name="l00985"></a>00985       } 
<a name="l00986"></a>00986 
<a name="l00987"></a>00987         <span class="comment">//-------------------------</span>
<a name="l00988"></a>00988         <span class="comment">// starting chain edges</span>
<a name="l00989"></a>00989         <span class="comment">//-------------------------</span>
<a name="l00990"></a>00990         vector&lt;FEdge*&gt;::iterator fe,fend;
<a name="l00991"></a>00991         vector&lt;FEdge*&gt;&amp; fedges = iBrother.<a class="code" href="classSShape.html#22ba15d180a23feee42de59e05c2caec">GetChains</a>();
<a name="l00992"></a>00992         <span class="keywordflow">for</span>(fe=fedges.begin(),fend=fedges.end();
<a name="l00993"></a>00993         fe!=fend;
<a name="l00994"></a>00994         fe++)
<a name="l00995"></a>00995         {
<a name="l00996"></a>00996           _chains.push_back((FEdge*)((*fe)-&gt;userdata));
<a name="l00997"></a>00997         }
<a name="l00998"></a>00998         
<a name="l00999"></a>00999     
<a name="l01000"></a>01000     <span class="comment">//-------------------------</span>
<a name="l01001"></a>01001     <span class="comment">// remap edges in vertices:</span>
<a name="l01002"></a>01002     <span class="comment">//-------------------------</span>
<a name="l01003"></a>01003     <span class="keywordflow">for</span>(sv=_verticesList.begin(),svend=_verticesList.end();
<a name="l01004"></a>01004         sv!=svend;
<a name="l01005"></a>01005         sv++)
<a name="l01006"></a>01006       {
<a name="l01007"></a>01007         <span class="keyword">const</span> vector&lt;FEdge*&gt;&amp; fedgeList = (*sv)-&gt;fedges();
<a name="l01008"></a>01008         vector&lt;FEdge*&gt; newfedgelist;
<a name="l01009"></a>01009         <span class="keywordflow">for</span>(vector&lt;FEdge*&gt;::const_iterator fed=fedgeList.begin(),fedend=fedgeList.end();
<a name="l01010"></a>01010             fed!=fedend;
<a name="l01011"></a>01011             fed++)
<a name="l01012"></a>01012           {
<a name="l01013"></a>01013             FEdge *current = *fed;
<a name="l01014"></a>01014             newfedgelist.push_back((FEdge*)current-&gt;userdata);
<a name="l01015"></a>01015           }
<a name="l01016"></a>01016         (*sv)-&gt;SetFEdges(newfedgelist); 
<a name="l01017"></a>01017       }
<a name="l01018"></a>01018     
<a name="l01019"></a>01019     <span class="comment">//-------------------------------------</span>
<a name="l01020"></a>01020     <span class="comment">// remap vertices and nextedge in edges:</span>
<a name="l01021"></a>01021     <span class="comment">//-------------------------------------</span>
<a name="l01022"></a>01022     <span class="keywordflow">for</span>(e=_edgesList.begin(),eend=_edgesList.end();
<a name="l01023"></a>01023         e!=eend;
<a name="l01024"></a>01024         e++)
<a name="l01025"></a>01025       {
<a name="l01026"></a>01026         (*e)-&gt;SetVertexA((<a class="code" href="classSVertex.html">SVertex</a>*)((*e)-&gt;vertexA()-&gt;userdata));
<a name="l01027"></a>01027         (*e)-&gt;SetVertexB((<a class="code" href="classSVertex.html">SVertex</a>*)((*e)-&gt;vertexB()-&gt;userdata));
<a name="l01028"></a>01028         (*e)-&gt;SetNextEdge((FEdge*)((*e)-&gt;nextEdge()-&gt;userdata));
<a name="l01029"></a>01029         (*e)-&gt;SetPreviousEdge((FEdge*)((*e)-&gt;previousEdge()-&gt;userdata));
<a name="l01030"></a>01030       }
<a name="l01031"></a>01031     
<a name="l01032"></a>01032 
<a name="l01033"></a>01033     <span class="comment">// reset all brothers userdata to NULL:</span>
<a name="l01034"></a>01034     <span class="comment">//-------------------------------------</span>
<a name="l01035"></a>01035     <span class="comment">//---------</span>
<a name="l01036"></a>01036     <span class="comment">// vertices</span>
<a name="l01037"></a>01037     <span class="comment">//---------</span>
<a name="l01038"></a>01038     <span class="keywordflow">for</span>(sv=_verticesList.begin(),svend=_verticesList.end();
<a name="l01039"></a>01039         sv!=svend;
<a name="l01040"></a>01040         sv++)
<a name="l01041"></a>01041       {
<a name="l01042"></a>01042         (*sv)-&gt;userdata = NULL;
<a name="l01043"></a>01043       }
<a name="l01044"></a>01044 
<a name="l01045"></a>01045     <span class="comment">//------</span>
<a name="l01046"></a>01046     <span class="comment">// edges</span>
<a name="l01047"></a>01047     <span class="comment">//------</span>
<a name="l01048"></a>01048     <span class="keywordflow">for</span>(e=_edgesList.begin(),eend=_edgesList.end();
<a name="l01049"></a>01049         e!=eend;
<a name="l01050"></a>01050         e++)
<a name="l01051"></a>01051       {
<a name="l01052"></a>01052         (*e)-&gt;userdata = NULL;
<a name="l01053"></a>01053       }  
<a name="l01054"></a>01054   }
<a name="l01056"></a><a class="code" href="classSShape.html#9a56eff980ce58fbb603bacdc8877478">01056</a>   <span class="keyword">virtual</span> SShape * dupplicate()
<a name="l01057"></a>01057   {
<a name="l01058"></a>01058     SShape *clone = <span class="keyword">new</span> SShape(*<span class="keyword">this</span>);
<a name="l01059"></a>01059     <span class="keywordflow">return</span> clone;
<a name="l01060"></a>01060   }
<a name="l01062"></a><a class="code" href="classSShape.html#bf2d8eb77093f13a810697eea4422f97">01062</a>   <span class="keyword">virtual</span> <span class="keyword">inline</span> ~SShape()
<a name="l01063"></a>01063   {
<a name="l01064"></a>01064     vector&lt;SVertex*&gt;::iterator sv,svend;
<a name="l01065"></a>01065     vector&lt;FEdge*&gt;::iterator e,eend;
<a name="l01066"></a>01066     <span class="keywordflow">if</span>(0 != _verticesList.size())
<a name="l01067"></a>01067       {
<a name="l01068"></a>01068         <span class="keywordflow">for</span>(sv=_verticesList.begin(),svend=_verticesList.end();
<a name="l01069"></a>01069             sv!=svend;
<a name="l01070"></a>01070             sv++)
<a name="l01071"></a>01071           {
<a name="l01072"></a>01072             <span class="keyword">delete</span> (*sv);
<a name="l01073"></a>01073           }
<a name="l01074"></a>01074         _verticesList.clear();
<a name="l01075"></a>01075       }
<a name="l01076"></a>01076 
<a name="l01077"></a>01077     <span class="keywordflow">if</span>(0 != _edgesList.size())
<a name="l01078"></a>01078       {
<a name="l01079"></a>01079         <span class="keywordflow">for</span>(e=_edgesList.begin(),eend=_edgesList.end();
<a name="l01080"></a>01080             e!=eend;
<a name="l01081"></a>01081             e++)
<a name="l01082"></a>01082           {
<a name="l01083"></a>01083             <span class="keyword">delete</span> (*e);
<a name="l01084"></a>01084           }
<a name="l01085"></a>01085         _edgesList.clear();
<a name="l01086"></a>01086       }
<a name="l01087"></a>01087 
<a name="l01089"></a>01089     <span class="comment">//-----------------------</span>
<a name="l01090"></a>01090     <span class="keywordflow">if</span>(0 != _chains.size())
<a name="l01091"></a>01091       {
<a name="l01092"></a>01092         _chains.clear();
<a name="l01093"></a>01093       }
<a name="l01094"></a>01094   }
<a name="l01095"></a>01095 
<a name="l01097"></a><a class="code" href="classSShape.html#6f77bccddee3bb60ca44a9a5bb937be0">01097</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> AddEdge(FEdge *iEdge)
<a name="l01098"></a>01098     {
<a name="l01099"></a>01099       _edgesList.push_back(iEdge);
<a name="l01100"></a>01100     }
<a name="l01101"></a>01101 
<a name="l01105"></a><a class="code" href="classSShape.html#2b090ecf9dec78b56dabf7d23dfa5b4c">01105</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> AddNewVertex(<a class="code" href="classSVertex.html">SVertex</a>* iv) {iv-&gt;<a class="code" href="classSVertex.html#3bb8912d4cdfa6a5173dde3aecc1d0fb">SetShape</a>(<span class="keyword">this</span>);_verticesList.push_back(iv);}
<a name="l01106"></a>01106   <span class="keyword">inline</span> <span class="keywordtype">void</span> AddChain(FEdge *iEdge){
<a name="l01107"></a>01107     _chains.push_back(iEdge);
<a name="l01108"></a>01108   }
<a name="l01109"></a>01109 
<a name="l01110"></a>01110   <span class="keyword">inline</span> <a class="code" href="classSVertex.html">SVertex</a> * CreateSVertex(<span class="keyword">const</span> Vec3r&amp; P3D, <span class="keyword">const</span> Vec3r&amp; P2D, <span class="keyword">const</span> <a class="code" href="classId.html">Id</a>&amp; <span class="keywordtype">id</span>)
<a name="l01111"></a>01111   {
<a name="l01112"></a>01112     <a class="code" href="classSVertex.html">SVertex</a> *Ia = <span class="keyword">new</span> <a class="code" href="classSVertex.html">SVertex</a>(P3D, <span class="keywordtype">id</span>);
<a name="l01113"></a>01113     Ia-&gt;<a class="code" href="classSVertex.html#7ca3d9f8cc735e13352078739e207c0a">SetPoint2D</a>(P2D);
<a name="l01114"></a>01114     AddNewVertex(Ia);
<a name="l01115"></a>01115     <span class="keywordflow">return</span> Ia;
<a name="l01116"></a>01116   }
<a name="l01117"></a>01117   <span class="comment">/* splits an edge into several edges. </span>
<a name="l01118"></a>01118 <span class="comment">   *  The edge's vertices are passed rather than </span>
<a name="l01119"></a>01119 <span class="comment">   *  the edge itself. This way, all feature edges (SILHOUETTE,</span>
<a name="l01120"></a>01120 <span class="comment">   *  CREASE, BORDER) are splitted in the same time.</span>
<a name="l01121"></a>01121 <span class="comment">   *  The processed edges are flagged as done (using the userdata</span>
<a name="l01122"></a>01122 <span class="comment">   *  flag).One single new vertex is created whereas </span>
<a name="l01123"></a>01123 <span class="comment">   *  several splitted edges might created for the different </span>
<a name="l01124"></a>01124 <span class="comment">   *  kinds of edges. These new elements are added to the lists</span>
<a name="l01125"></a>01125 <span class="comment">   *  maintained by the shape.</span>
<a name="l01126"></a>01126 <span class="comment">   *  new chains are also created.</span>
<a name="l01127"></a>01127 <span class="comment">   *    ioA</span>
<a name="l01128"></a>01128 <span class="comment">   *      The first vertex for the edge that gets splitted</span>
<a name="l01129"></a>01129 <span class="comment">   *    ioB</span>
<a name="l01130"></a>01130 <span class="comment">   *      The second vertex for the edge that gets splitted</span>
<a name="l01131"></a>01131 <span class="comment">   *    iParameters</span>
<a name="l01132"></a>01132 <span class="comment">   *      A vector containing 2D real vectors indicating the parameters</span>
<a name="l01133"></a>01133 <span class="comment">   *      giving the intersections coordinates in 3D and in 2D.</span>
<a name="l01134"></a>01134 <span class="comment">   *      These intersections points must be sorted from B to A.</span>
<a name="l01135"></a>01135 <span class="comment">   *      Each parameter defines the intersection point I as I=A+T*AB.</span>
<a name="l01136"></a>01136 <span class="comment">   *      T&lt;0 and T&gt;1 are then incorrect insofar as they give intersections</span>
<a name="l01137"></a>01137 <span class="comment">   *      points that lie outside the segment.</span>
<a name="l01138"></a>01138 <span class="comment">   *    ioNewEdges</span>
<a name="l01139"></a>01139 <span class="comment">   *      The edges that are newly created (the initial edges are not </span>
<a name="l01140"></a>01140 <span class="comment">   *      included) are added to this list.</span>
<a name="l01141"></a>01141 <span class="comment">   */</span>
<a name="l01142"></a>01142   <span class="keyword">inline</span> <span class="keywordtype">void</span> SplitEdge(FEdge *fe, <span class="keyword">const</span> vector&lt;Vec2r&gt;&amp; iParameters, vector&lt;FEdge*&gt;&amp; ioNewEdges)
<a name="l01143"></a>01143     {
<a name="l01144"></a>01144     
<a name="l01145"></a>01145     <a class="code" href="classSVertex.html">SVertex</a> *ioA = fe-&gt;<a class="code" href="classFEdge.html#93fffa48a5ca729a446882b6fe99edba">vertexA</a>();
<a name="l01146"></a>01146     <a class="code" href="classSVertex.html">SVertex</a> *ioB = fe-&gt;<a class="code" href="classFEdge.html#00458b207b0cc7ae45f26f158088b0b1">vertexB</a>();
<a name="l01147"></a>01147     Vec3r A = ioA-&gt;<a class="code" href="classSVertex.html#8f2ea75b6078ce295e8da77a4e919dab">point3D</a>();
<a name="l01148"></a>01148     Vec3r B = ioB-&gt;<a class="code" href="classSVertex.html#8f2ea75b6078ce295e8da77a4e919dab">point3D</a>();
<a name="l01149"></a>01149     Vec3r a = ioA-&gt;<a class="code" href="classSVertex.html#70626b19f52120aaef27d0feda776999">point2D</a>();
<a name="l01150"></a>01150     Vec3r b = ioB-&gt;<a class="code" href="classSVertex.html#70626b19f52120aaef27d0feda776999">point2D</a>();
<a name="l01151"></a>01151     <a class="code" href="classSVertex.html">SVertex</a> *svA, *svB;
<a name="l01152"></a>01152 
<a name="l01153"></a>01153     Vec3r newpoint3d,newpoint2d;
<a name="l01154"></a>01154     vector&lt;SVertex*&gt; intersections;
<a name="l01155"></a>01155     real t,T;
<a name="l01156"></a>01156     <span class="keywordflow">for</span>(vector&lt;Vec2r&gt;::const_iterator p=iParameters.begin(),pend=iParameters.end();
<a name="l01157"></a>01157     p!=pend;
<a name="l01158"></a>01158     p++)
<a name="l01159"></a>01159     {
<a name="l01160"></a>01160       T=(*p)[0];
<a name="l01161"></a>01161       t=(*p)[1];
<a name="l01162"></a>01162 
<a name="l01163"></a>01163       <span class="keywordflow">if</span>((t &lt; 0) || (t &gt; 1))
<a name="l01164"></a>01164         cerr &lt;&lt; <span class="stringliteral">"Warning: Intersection out of range for edge "</span> &lt;&lt; ioA-&gt;<a class="code" href="classSVertex.html#67c9cf6326a694c4b411a2b32c90c56f">getId</a>() &lt;&lt; <span class="stringliteral">" - "</span> &lt;&lt; ioB-&gt;<a class="code" href="classSVertex.html#67c9cf6326a694c4b411a2b32c90c56f">getId</a>() &lt;&lt; endl;
<a name="l01165"></a>01165     
<a name="l01166"></a>01166       <span class="comment">// compute the 3D and 2D coordinates for the intersections points:</span>
<a name="l01167"></a>01167       newpoint3d = Vec3r(A + T*(B-A));
<a name="l01168"></a>01168       newpoint2d = Vec3r(a + t*(b-a));
<a name="l01169"></a>01169 
<a name="l01170"></a>01170       <span class="comment">// create new SVertex:</span>
<a name="l01171"></a>01171       <span class="comment">// (we keep B's id)</span>
<a name="l01172"></a>01172       <a class="code" href="classSVertex.html">SVertex</a>* newVertex = <span class="keyword">new</span> <a class="code" href="classSVertex.html">SVertex</a>(newpoint3d, ioB-&gt;<a class="code" href="classSVertex.html#67c9cf6326a694c4b411a2b32c90c56f">getId</a>());
<a name="l01173"></a>01173       newVertex-&gt;<a class="code" href="classSVertex.html#7ca3d9f8cc735e13352078739e207c0a">SetPoint2D</a>(newpoint2d);
<a name="l01174"></a>01174       
<a name="l01175"></a>01175       <span class="comment">// Add this vertex to the intersections list:</span>
<a name="l01176"></a>01176       intersections.push_back(newVertex);
<a name="l01177"></a>01177 
<a name="l01178"></a>01178       <span class="comment">// Add this vertex to this sshape:</span>
<a name="l01179"></a>01179       AddNewVertex(newVertex);
<a name="l01180"></a>01180     }
<a name="l01181"></a>01181     
<a name="l01182"></a>01182     <span class="keywordflow">for</span>(vector&lt;SVertex*&gt;::iterator sv=intersections.begin(),svend=intersections.end();
<a name="l01183"></a>01183     sv!=svend;
<a name="l01184"></a>01184     sv++)
<a name="l01185"></a>01185     {
<a name="l01186"></a>01186       svA = fe-&gt;<a class="code" href="classFEdge.html#93fffa48a5ca729a446882b6fe99edba">vertexA</a>();
<a name="l01187"></a>01187       svB = fe-&gt;<a class="code" href="classFEdge.html#00458b207b0cc7ae45f26f158088b0b1">vertexB</a>();
<a name="l01188"></a>01188         
<a name="l01189"></a>01189       <span class="comment">// We split edge AB into AA' and A'B. A' and A'B are created.</span>
<a name="l01190"></a>01190       <span class="comment">// AB becomes (address speaking) AA'. B is updated.</span>
<a name="l01191"></a>01191       <span class="comment">//--------------------------------------------------</span>
<a name="l01192"></a>01192       <span class="comment">// The edge AB becomes edge AA'.</span>
<a name="l01193"></a>01193       (fe)-&gt;SetVertexB((*sv));
<a name="l01194"></a>01194       <span class="comment">// a new edge, A'B is created.</span>
<a name="l01195"></a>01195       FEdge *newEdge;
<a name="l01196"></a>01196       <span class="keywordflow">if</span>(fe-&gt;<a class="code" href="classFEdge.html#4d53d5a77fdef5ea5a7b610d10572b58">isSmooth</a>()){
<a name="l01197"></a>01197         newEdge = <span class="keyword">new</span> FEdgeSmooth((*sv), svB);
<a name="l01198"></a>01198         FEdgeSmooth * se = dynamic_cast&lt;FEdgeSmooth*&gt;(newEdge);
<a name="l01199"></a>01199         FEdgeSmooth * fes = dynamic_cast&lt;FEdgeSmooth*&gt;(fe);
<a name="l01200"></a>01200         se-&gt;<a class="code" href="classFEdgeSmooth.html#9dbf9495fe51b1c78cb6c742cbe64f98">SetMaterialIndex</a>(fes-&gt;materialIndex());
<a name="l01201"></a>01201       }<span class="keywordflow">else</span>{
<a name="l01202"></a>01202         newEdge = <span class="keyword">new</span> FEdgeSharp((*sv), svB);
<a name="l01203"></a>01203         FEdgeSharp * se = dynamic_cast&lt;FEdgeSharp*&gt;(newEdge);
<a name="l01204"></a>01204         FEdgeSharp * fes = dynamic_cast&lt;FEdgeSharp*&gt;(fe);
<a name="l01205"></a>01205         se-&gt;<a class="code" href="classFEdgeSharp.html#1d636c91b555379af06f05b55b64ca6c">SetaMaterialIndex</a>(fes-&gt;aMaterialIndex());
<a name="l01206"></a>01206         se-&gt;<a class="code" href="classFEdgeSharp.html#38eb9d2d517d74e63184ef11762f46c9">SetbMaterialIndex</a>(fes-&gt;bMaterialIndex());
<a name="l01207"></a>01207       }
<a name="l01208"></a>01208         
<a name="l01209"></a>01209       newEdge-&gt;<a class="code" href="classFEdge.html#30304d45ddff3272a7496efab801dd83">SetNature</a>((fe)-&gt;getNature());
<a name="l01210"></a>01210       
<a name="l01211"></a>01211 
<a name="l01212"></a>01212       <span class="comment">// to build a new chain:</span>
<a name="l01213"></a>01213       AddChain(newEdge);
<a name="l01214"></a>01214       <span class="comment">// add the new edge to the sshape edges list.</span>
<a name="l01215"></a>01215       AddEdge(newEdge);
<a name="l01216"></a>01216       <span class="comment">// add new edge to the list of new edges passed as argument:</span>
<a name="l01217"></a>01217       ioNewEdges.push_back(newEdge);
<a name="l01218"></a>01218 
<a name="l01219"></a>01219       <span class="comment">// update edge A'B for the next pointing edge</span>
<a name="l01220"></a>01220       newEdge-&gt;<a class="code" href="classFEdge.html#180be4be13b1b0af4dee10093ab5f295">SetNextEdge</a>((fe)-&gt;nextEdge());
<a name="l01221"></a>01221       fe-&gt;<a class="code" href="classFEdge.html#0f051f7f2d16c5abc6a91e0602d4841e">nextEdge</a>()-&gt;<a class="code" href="classFEdge.html#db927ea9d5f86cda05f96c393f2ff4be">SetPreviousEdge</a>(newEdge);
<a name="l01222"></a>01222       <a class="code" href="classId.html">Id</a> id(fe-&gt;<a class="code" href="classFEdge.html#67c9cf6326a694c4b411a2b32c90c56f">getId</a>().<a class="code" href="classId.html#0786e8bac9ce774c163d0f3cca4ad2bb">getFirst</a>(), fe-&gt;<a class="code" href="classFEdge.html#67c9cf6326a694c4b411a2b32c90c56f">getId</a>().<a class="code" href="classId.html#566043dd235c581f92dcd6f3cef6133f">getSecond</a>()+1);
<a name="l01223"></a>01223       newEdge-&gt;<a class="code" href="classFEdge.html#6d8d9b7436118c053c323a4367d70424">SetId</a>(fe-&gt;<a class="code" href="classFEdge.html#67c9cf6326a694c4b411a2b32c90c56f">getId</a>());
<a name="l01224"></a>01224       fe-&gt;<a class="code" href="classFEdge.html#6d8d9b7436118c053c323a4367d70424">SetId</a>(<span class="keywordtype">id</span>);
<a name="l01225"></a>01225 
<a name="l01226"></a>01226       <span class="comment">// update edge AA' for the next pointing edge</span>
<a name="l01227"></a>01227       <span class="comment">//ioEdge-&gt;SetNextEdge(newEdge);</span>
<a name="l01228"></a>01228       (fe)-&gt;SetNextEdge(NULL);
<a name="l01229"></a>01229 
<a name="l01230"></a>01230       <span class="comment">// update vertex pointing edges list:</span>
<a name="l01231"></a>01231       <span class="comment">// -- vertex B --</span>
<a name="l01232"></a>01232       svB-&gt;<a class="code" href="classSVertex.html#b09fd5b6ad8e1695e4b903cbae7ffa9b">Replace</a>((fe), newEdge);
<a name="l01233"></a>01233       <span class="comment">// -- vertex A' --</span>
<a name="l01234"></a>01234       (*sv)-&gt;AddFEdge((fe));
<a name="l01235"></a>01235       (*sv)-&gt;AddFEdge(newEdge);
<a name="l01236"></a>01236     }
<a name="l01237"></a>01237           
<a name="l01238"></a>01238     }
<a name="l01239"></a>01239 
<a name="l01240"></a>01240   <span class="comment">/* splits an edge into 2 edges. The new vertex and edge are added</span>
<a name="l01241"></a>01241 <span class="comment">   *  to the sshape list of vertices and edges</span>
<a name="l01242"></a>01242 <span class="comment">   *  a new chain is also created.</span>
<a name="l01243"></a>01243 <span class="comment">   *  returns the new edge.</span>
<a name="l01244"></a>01244 <span class="comment">   *    ioEdge</span>
<a name="l01245"></a>01245 <span class="comment">   *      The edge that gets splitted</span>
<a name="l01246"></a>01246 <span class="comment">   *    newpoint</span>
<a name="l01247"></a>01247 <span class="comment">   *      x,y,z coordinates of the new point.</span>
<a name="l01248"></a>01248 <span class="comment">   */</span>
<a name="l01249"></a>01249   <span class="keyword">inline</span> FEdge* SplitEdgeIn2(FEdge* ioEdge, <a class="code" href="classSVertex.html">SVertex</a> * ioNewVertex)
<a name="l01250"></a>01250     {
<a name="l01251"></a>01251       <a class="code" href="classSVertex.html">SVertex</a> *A = ioEdge-&gt;<a class="code" href="classFEdge.html#93fffa48a5ca729a446882b6fe99edba">vertexA</a>();
<a name="l01252"></a>01252       <a class="code" href="classSVertex.html">SVertex</a> *B = ioEdge-&gt;<a class="code" href="classFEdge.html#00458b207b0cc7ae45f26f158088b0b1">vertexB</a>();
<a name="l01253"></a>01253 
<a name="l01254"></a>01254       
<a name="l01255"></a>01255       <span class="comment">// We split edge AB into AA' and A'B. A' and A'B are created.</span>
<a name="l01256"></a>01256       <span class="comment">// AB becomes (address speaking) AA'. B is updated.</span>
<a name="l01257"></a>01257       <span class="comment">//--------------------------------------------------</span>
<a name="l01258"></a>01258       
<a name="l01259"></a>01259       <span class="comment">// a new edge, A'B is created.</span>
<a name="l01260"></a>01260       FEdge *newEdge;
<a name="l01261"></a>01261       <span class="keywordflow">if</span>(ioEdge-&gt;<a class="code" href="classFEdge.html#4d53d5a77fdef5ea5a7b610d10572b58">isSmooth</a>()){
<a name="l01262"></a>01262         newEdge = <span class="keyword">new</span> FEdgeSmooth(ioNewVertex, B);
<a name="l01263"></a>01263         FEdgeSmooth * se = dynamic_cast&lt;FEdgeSmooth*&gt;(newEdge);
<a name="l01264"></a>01264         FEdgeSmooth * fes = dynamic_cast&lt;FEdgeSmooth*&gt;(ioEdge);
<a name="l01265"></a>01265         se-&gt;<a class="code" href="classFEdgeSmooth.html#9dbf9495fe51b1c78cb6c742cbe64f98">SetMaterialIndex</a>(fes-&gt;materialIndex());
<a name="l01266"></a>01266       }<span class="keywordflow">else</span>{
<a name="l01267"></a>01267         newEdge = <span class="keyword">new</span> FEdgeSharp(ioNewVertex, B);
<a name="l01268"></a>01268         FEdgeSharp * se = dynamic_cast&lt;FEdgeSharp*&gt;(newEdge);
<a name="l01269"></a>01269         FEdgeSharp * fes = dynamic_cast&lt;FEdgeSharp*&gt;(ioEdge);
<a name="l01270"></a>01270         se-&gt;<a class="code" href="classFEdgeSharp.html#1d636c91b555379af06f05b55b64ca6c">SetaMaterialIndex</a>(fes-&gt;aMaterialIndex());
<a name="l01271"></a>01271         se-&gt;<a class="code" href="classFEdgeSharp.html#38eb9d2d517d74e63184ef11762f46c9">SetbMaterialIndex</a>(fes-&gt;bMaterialIndex());
<a name="l01272"></a>01272       }
<a name="l01273"></a>01273       newEdge-&gt;<a class="code" href="classFEdge.html#30304d45ddff3272a7496efab801dd83">SetNature</a>(ioEdge-&gt;<a class="code" href="classFEdge.html#58a18b3ad438cbaf7fa2dc5c1dacc4c7">getNature</a>());
<a name="l01274"></a>01274       
<a name="l01275"></a>01275       
<a name="l01276"></a>01276       <span class="keywordflow">if</span>(ioEdge-&gt;<a class="code" href="classFEdge.html#0f051f7f2d16c5abc6a91e0602d4841e">nextEdge</a>() != 0)
<a name="l01277"></a>01277         ioEdge-&gt;<a class="code" href="classFEdge.html#0f051f7f2d16c5abc6a91e0602d4841e">nextEdge</a>()-&gt;<a class="code" href="classFEdge.html#db927ea9d5f86cda05f96c393f2ff4be">SetPreviousEdge</a>(newEdge);
<a name="l01278"></a>01278 
<a name="l01279"></a>01279       <span class="comment">// update edge A'B for the next pointing edge</span>
<a name="l01280"></a>01280       newEdge-&gt;<a class="code" href="classFEdge.html#180be4be13b1b0af4dee10093ab5f295">SetNextEdge</a>(ioEdge-&gt;<a class="code" href="classFEdge.html#0f051f7f2d16c5abc6a91e0602d4841e">nextEdge</a>());
<a name="l01281"></a>01281       <span class="comment">// update edge A'B for the previous pointing edge</span>
<a name="l01282"></a>01282       newEdge-&gt;<a class="code" href="classFEdge.html#db927ea9d5f86cda05f96c393f2ff4be">SetPreviousEdge</a>(0); <span class="comment">// because it is now a TVertex</span>
<a name="l01283"></a>01283       <a class="code" href="classId.html">Id</a> id(ioEdge-&gt;<a class="code" href="classFEdge.html#67c9cf6326a694c4b411a2b32c90c56f">getId</a>().<a class="code" href="classId.html#0786e8bac9ce774c163d0f3cca4ad2bb">getFirst</a>(), ioEdge-&gt;<a class="code" href="classFEdge.html#67c9cf6326a694c4b411a2b32c90c56f">getId</a>().<a class="code" href="classId.html#566043dd235c581f92dcd6f3cef6133f">getSecond</a>()+1);
<a name="l01284"></a>01284       newEdge-&gt;<a class="code" href="classFEdge.html#6d8d9b7436118c053c323a4367d70424">SetId</a>(ioEdge-&gt;<a class="code" href="classFEdge.html#67c9cf6326a694c4b411a2b32c90c56f">getId</a>());
<a name="l01285"></a>01285       ioEdge-&gt;<a class="code" href="classFEdge.html#6d8d9b7436118c053c323a4367d70424">SetId</a>(<span class="keywordtype">id</span>);
<a name="l01286"></a>01286    
<a name="l01287"></a>01287       <span class="comment">// update edge AA' for the next pointing edge</span>
<a name="l01288"></a>01288       ioEdge-&gt;<a class="code" href="classFEdge.html#180be4be13b1b0af4dee10093ab5f295">SetNextEdge</a>(0); <span class="comment">// because it is now a TVertex</span>
<a name="l01289"></a>01289 
<a name="l01290"></a>01290       <span class="comment">// update vertex pointing edges list:</span>
<a name="l01291"></a>01291       <span class="comment">// -- vertex B --</span>
<a name="l01292"></a>01292       B-&gt;<a class="code" href="classSVertex.html#b09fd5b6ad8e1695e4b903cbae7ffa9b">Replace</a>(ioEdge, newEdge);
<a name="l01293"></a>01293       <span class="comment">// -- vertex A' --</span>
<a name="l01294"></a>01294       ioNewVertex-&gt;AddFEdge(ioEdge);
<a name="l01295"></a>01295       ioNewVertex-&gt;AddFEdge(newEdge);
<a name="l01296"></a>01296 
<a name="l01297"></a>01297       <span class="comment">// to build a new chain:</span>
<a name="l01298"></a>01298       AddChain(newEdge);
<a name="l01299"></a>01299       AddEdge(newEdge); <span class="comment">// FIXME ??</span>
<a name="l01300"></a>01300       
<a name="l01301"></a>01301       <span class="comment">// The edge AB becomes edge AA'.</span>
<a name="l01302"></a>01302       ioEdge-&gt;<a class="code" href="classFEdge.html#e1f131a94dcf1c9f24260bf3c14b6ee4">SetVertexB</a>(ioNewVertex);
<a name="l01303"></a>01303       
<a name="l01304"></a>01304       <span class="keywordflow">if</span>(ioEdge-&gt;<a class="code" href="classFEdge.html#4d53d5a77fdef5ea5a7b610d10572b58">isSmooth</a>()){
<a name="l01305"></a>01305         ((FEdgeSmooth*)newEdge)-&gt;SetFace(((FEdgeSmooth*)ioEdge)-&gt;face());
<a name="l01306"></a>01306       }
<a name="l01307"></a>01307       
<a name="l01308"></a>01308       <span class="keywordflow">return</span> newEdge;
<a name="l01309"></a>01309     }
<a name="l01310"></a>01310 
<a name="l01312"></a><a class="code" href="classSShape.html#c50cc491a43eb25bae60a524c4f4a07e">01312</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> SetBBox(<span class="keyword">const</span> BBox&lt;Vec3r&gt;&amp; iBBox) {_BBox = iBBox;}
<a name="l01313"></a>01313 
<a name="l01315"></a><a class="code" href="classSShape.html#5c04808390705246d0ce3924db0eb7a2">01315</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> ComputeBBox()
<a name="l01316"></a>01316   {
<a name="l01317"></a>01317     <span class="keywordflow">if</span>(0 == _verticesList.size())
<a name="l01318"></a>01318       <span class="keywordflow">return</span>;
<a name="l01319"></a>01319 
<a name="l01320"></a>01320     Vec3r firstVertex = _verticesList[0]-&gt;point3D();
<a name="l01321"></a>01321     real XMax = firstVertex[0];
<a name="l01322"></a>01322     real YMax = firstVertex[1];
<a name="l01323"></a>01323     real ZMax = firstVertex[2];
<a name="l01324"></a>01324 
<a name="l01325"></a>01325     real XMin = firstVertex[0];
<a name="l01326"></a>01326     real YMin = firstVertex[1];
<a name="l01327"></a>01327     real ZMin = firstVertex[2];
<a name="l01328"></a>01328 
<a name="l01329"></a>01329     vector&lt;SVertex*&gt;::iterator v,vend;
<a name="l01330"></a>01330     <span class="comment">// parse all the coordinates to find </span>
<a name="l01331"></a>01331     <span class="comment">// the Xmax, YMax, ZMax</span>
<a name="l01332"></a>01332     <span class="keywordflow">for</span>(v=_verticesList.begin(),vend=_verticesList.end();
<a name="l01333"></a>01333         v!=vend;
<a name="l01334"></a>01334         v++)
<a name="l01335"></a>01335       {
<a name="l01336"></a>01336         Vec3r vertex = (*v)-&gt;point3D();
<a name="l01337"></a>01337         <span class="comment">// X</span>
<a name="l01338"></a>01338         real x = vertex[0];
<a name="l01339"></a>01339         <span class="keywordflow">if</span>(x &gt; XMax)
<a name="l01340"></a>01340           XMax = x;
<a name="l01341"></a>01341         <span class="keywordflow">if</span>(x &lt; XMin)
<a name="l01342"></a>01342           XMin = x;
<a name="l01343"></a>01343         
<a name="l01344"></a>01344         <span class="comment">// Y</span>
<a name="l01345"></a>01345         real y = vertex[1];
<a name="l01346"></a>01346         <span class="keywordflow">if</span>(y &gt; YMax)
<a name="l01347"></a>01347           YMax = y;
<a name="l01348"></a>01348         <span class="keywordflow">if</span>(y &lt; YMin)
<a name="l01349"></a>01349           YMin = y;
<a name="l01350"></a>01350         
<a name="l01351"></a>01351         <span class="comment">// Z</span>
<a name="l01352"></a>01352         real z = vertex[2];
<a name="l01353"></a>01353         <span class="keywordflow">if</span>(z &gt; ZMax)
<a name="l01354"></a>01354           ZMax = z;
<a name="l01355"></a>01355         <span class="keywordflow">if</span>(z &lt; ZMin)
<a name="l01356"></a>01356           ZMin = z;
<a name="l01357"></a>01357       }
<a name="l01358"></a>01358     
<a name="l01359"></a>01359     
<a name="l01360"></a>01360     SetBBox(BBox&lt;Vec3r&gt;(Vec3r(XMin, YMin, ZMin), Vec3r(XMax, YMax, ZMax)));
<a name="l01361"></a>01361   }
<a name="l01362"></a>01362 
<a name="l01363"></a>01363   <span class="keyword">inline</span> <span class="keywordtype">void</span> RemoveEdgeFromChain(FEdge *iEdge)
<a name="l01364"></a>01364   {
<a name="l01365"></a>01365     <span class="keywordflow">for</span>(vector&lt;FEdge*&gt;::iterator fe=_chains.begin(), feend=_chains.end();
<a name="l01366"></a>01366     fe!=feend;
<a name="l01367"></a>01367     fe++)
<a name="l01368"></a>01368     {
<a name="l01369"></a>01369       <span class="keywordflow">if</span>(iEdge == (*fe))
<a name="l01370"></a>01370       {
<a name="l01371"></a>01371         _chains.erase(fe);
<a name="l01372"></a>01372         <span class="keywordflow">break</span>;
<a name="l01373"></a>01373       }
<a name="l01374"></a>01374     }
<a name="l01375"></a>01375   }
<a name="l01376"></a>01376 
<a name="l01377"></a>01377   <span class="keyword">inline</span> <span class="keywordtype">void</span> RemoveEdge(FEdge *iEdge)
<a name="l01378"></a>01378   {
<a name="l01379"></a>01379     <span class="keywordflow">for</span>(vector&lt;FEdge*&gt;::iterator fe=_edgesList.begin(), feend=_edgesList.end();
<a name="l01380"></a>01380     fe!=feend;
<a name="l01381"></a>01381     fe++)
<a name="l01382"></a>01382     {
<a name="l01383"></a>01383       <span class="keywordflow">if</span>(iEdge == (*fe))
<a name="l01384"></a>01384       {
<a name="l01385"></a>01385         _edgesList.erase(fe);
<a name="l01386"></a>01386         <span class="keywordflow">break</span>;
<a name="l01387"></a>01387       }
<a name="l01388"></a>01388     }
<a name="l01389"></a>01389   }
<a name="l01390"></a>01390 
<a name="l01391"></a>01391   <span class="comment">/* accessors */</span>
<a name="l01393"></a><a class="code" href="classSShape.html#fa2f4ec84de6ae0b01abec8c0c8233c5">01393</a>   <span class="keyword">inline</span> vector&lt;SVertex*&gt;&amp; GetVertexList() {<span class="keywordflow">return</span> _verticesList;} <span class="comment">// Get vertices list</span>
<a name="l01395"></a><a class="code" href="classSShape.html#1f3a5553b32168c566948cf4085ec4e7">01395</a> <span class="comment"></span>  <span class="keyword">inline</span> vector&lt;FEdge*&gt;&amp; GetEdgeList() {<span class="keywordflow">return</span> _edgesList;} <span class="comment">// Get edges list</span>
<a name="l01396"></a>01396   <span class="keyword">inline</span> vector&lt;FEdge*&gt;&amp; GetChains() {<span class="keywordflow">return</span> _chains;}
<a name="l01398"></a><a class="code" href="classSShape.html#274a7765c3404fb632708ac0b6dd0e87">01398</a>   <span class="keyword">inline</span> <span class="keyword">const</span> BBox&lt;Vec3r&gt;&amp; bbox() {<span class="keywordflow">return</span> _BBox;}
<a name="l01400"></a><a class="code" href="classSShape.html#1460e69fb497a76db706b09e22ca2f72">01400</a>   <span class="keyword">inline</span> <span class="keyword">const</span> <a class="code" href="classMaterial.html">Material</a>&amp; material(<span class="keywordtype">unsigned</span> i)<span class="keyword"> const </span>{<span class="keywordflow">return</span> _Materials[i];}
<a name="l01402"></a><a class="code" href="classSShape.html#b69b21c23cc451e2e0d332bee120c851">01402</a>   <span class="keyword">inline</span> <span class="keyword">const</span> vector&lt;Material&gt;&amp; materials()<span class="keyword"> const </span>{<span class="keywordflow">return</span> _Materials;}
<a name="l01403"></a>01403   <span class="keyword">inline</span> <a class="code" href="classViewShape.html">ViewShape</a> * viewShape() {<span class="keywordflow">return</span> _ViewShape;}
<a name="l01404"></a>01404   <span class="keyword">inline</span> <span class="keywordtype">float</span> importance()<span class="keyword"> const </span>{<span class="keywordflow">return</span> _importance;}
<a name="l01406"></a><a class="code" href="classSShape.html#3666dd3c70fc6d311ba63c739da27dd1">01406</a>   <span class="keyword">inline</span> <a class="code" href="classId.html">Id</a> getId()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _Id; }
<a name="l01407"></a>01407   
<a name="l01408"></a>01408   <span class="comment">/* Modififers */</span>
<a name="l01410"></a><a class="code" href="classSShape.html#4725623b57740ab8eaf9b85c24dfdb53">01410</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> SetId(<a class="code" href="classId.html">Id</a> <span class="keywordtype">id</span>) {_Id = id;}
<a name="l01412"></a><a class="code" href="classSShape.html#7f82f635850f10e9524515ab916263a2">01412</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> SetMaterials(<span class="keyword">const</span> vector&lt;Material&gt;&amp; iMaterials) {_Materials = iMaterials;}
<a name="l01413"></a>01413   <span class="keyword">inline</span> <span class="keywordtype">void</span> SetViewShape(<a class="code" href="classViewShape.html">ViewShape</a> *iShape) {_ViewShape = iShape;}
<a name="l01414"></a>01414   <span class="keyword">inline</span> <span class="keywordtype">void</span> SetImportance(<span class="keywordtype">float</span> importance){_importance = importance;}
<a name="l01415"></a>01415 };
<a name="l01416"></a>01416 
<a name="l01417"></a>01417 <span class="preprocessor">#endif // SILHOUETTE_H</span>
</pre></div></div>
<div align="center">
<div class="brighttitle"><hr/></div>
<div id='Footer'><table width='90%' border='0' class='footer'><tr>
<td align='left'>
Last modified 6 Mar 2008 </td><td align='center'>
<a href="http://sourceforge.net"><img src="http://sourceforge.net/sflogo.php?group_id=124602&amp;type=1" width="88" height="31" border="0" alt="SourceForge.net Logo"/></a>

</td>
<td align='right'>&copy; <a href="http://artis.imag.fr/Members/Stephane.Grabli">Stephane Grabli</a></td></tr></table>
</div>
</div>
</body>
</html>
