<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//$LANGUAGE"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Freestyle: Tutorial</title>
<link rel="stylesheet" href="grey.css" type="text/css">
</head>
<body>

<b>
<table width='100%' border='0' cellspacing='0' cellpadding='0'>
<tr>
<td align='center'><a href="http://freestyle.sourceforge.net">h<font class="brighttitle"> o m e</font></a></td>
<td align='center'><a href="index.html">d<font class="brighttitle"> o c u m e n t a t i o n</font></a></td>
<td align='center'><a href="hierarchy.html">c<font class="brighttitle"> l a s s   </font>h <font class="brighttitle"> i e r a r c h y</font></a></td>
</tr>
</table>
<div class="brighttitle"><hr/></div>
</b>
<div class="corpus">
<!-- Generated by Doxygen 1.5.1 -->
<h1><a class="anchor" name="Tutorial">Tutorial</a></h1><h2><a class="anchor" name="s1">
Configuring Freestyle</a></h2>
All the python examples are located under the 'style_modules' directory. If you define functions, predicates, shaders etc. in files that are located in other directories than the standard ones, you will need to complete the python path through the "Windows &gt; Options Window" dialog.<p>
Warning: any modification made outside a style module itself will not be taken into account automatically: you need to reset the interpreter, through the "Tools &gt; Reset Interpreter" menu item, before redrawing the strokes.<h2><a class="anchor" name="s2">
Before the Style</a></h2>
If we want to properly see the style we're about to write, we need to open a 3D model, to choose a proper viewpoint and to compute the <a class="el" href="classViewMap.html">ViewMap</a> of the scene. You can open a 3D model through the File &gt; Open menu. We'll work with the "simpleScene.3DS" model in this tutorial. Once it has been loaded, you can use the trackball to choose the viewpoint you want. Then, compute the <a class="el" href="classViewMap.html">ViewMap</a> using the Tools &gt; "Compute View Map" menu item. You have several useful display options. Here are some:<ul>
<li>e: show/hide the <a class="el" href="classViewMap.html">ViewMap</a></li><li>1: show the 3D model as solid</li><li>2: show the 3D model in wireframe</li><li>3: hide the 3D model</li></ul>
<p>
(All display options are accessible through "Help"&gt;"Control Bindings" Thus you can see the <a class="el" href="classViewMap.html">ViewMap</a> only by pressing <em>e</em> and <em>3</em>. <br>
  
<table border=0 cellpadding=0 cellspacing=0>
  <tr>
    <td align="center" width="50%"><img src="tutorial_3D.jpg" width="100%"></td>
    <td align="center" width="50%"><img src="tutorial_ViewMap.jpg" width="100%"></td>
  </tr>
  <tr>
    <td align="center">the 3D scene</td>
    <td align="center">the ViewMap</td>
  </tr>
</table>
 <br>
 The <a class="el" href="classViewMap.html">ViewMap</a> is now ready, we can write our Style Module. Let us create an empty file named "StyleModule0.py" in which we'll write our style module. Then, display the Style Modeler window using the Windows &gt; "Style Modeler Window" menu item, and press the '+' button that opens a file browsing window. Load then the "StyleModule0.py" file. A line with the StyleModule0.py is now visible in the Style Modeler window. Double-click on this line to make the Editor appear. We'll write our Style Module using this editor. Any change made in the file can be saved using the "save" button.<h2><a class="anchor" name="s3">
My first style module</a></h2>
Let us edit the file "StyleModule0.py" and try to write a style module that paints each visible line from red to green. The first line we need to write is this one: <br>
 <div class="fragment"><pre class="fragment">from Freestyle <span class="keyword">import</span> *
</pre></div> <br>
 It is the "include" instruction needed to use any Freestyle element in python. Any object that would be defined outside our StyleModule0.py file would require such an import command to be used in our style module. Through this import we can access all the <a class="el" href="classOperators.html">Operators</a> of the pipeline (see <a class="el" href="classOperators.html">Operators</a>) as well as any C++ predefined Function, Predicate or Shader.<br>
 We are now going to write the selection part of the style module: We said we want to apply our style only to visible lines, we therefore need to use the select operator together with a predicate that answers true for any visible line and false in every other cases. The QuantitativeInvisibilityUP1D built-in predicate exactly matches our need: It takes an integer as argument and answers true for any <a class="el" href="classInterface1D.html">Interface1D</a> whose quantitative invisibility equals this number. Here is how our selection line must look like: <br>
 <div class="fragment"><pre class="fragment"><a class="code" href="classOperators.html">Operators</a>.select(QuantitativeInvisibilityUP1D(0))
</pre></div> <br>
 After that call, our active set of elements contains all the visible <a class="el" href="classViewEdge.html">ViewEdge</a> of the <a class="el" href="classViewMap.html">ViewMap</a>. We can already build strokes from these <a class="el" href="classViewEdge.html">ViewEdge</a> (without chaining) and apply some shading. We said we wanted the color of our Strokes to eventually vary from red to green. The IncreasingColorShader <a class="el" href="classStrokeShader.html">StrokeShader</a> is designed for this kind of painting. We therefore add this <a class="el" href="classStrokeShader.html">StrokeShader</a> to the list of shaders that will be used to assign visual attributes to strokes: <br>
 <div class="fragment"><pre class="fragment">shaders_list = [IncreasingColorShader(1,0,0,1, 0,1,0,1)] 
</pre></div> <br>
 The first four numbers passed to the IncreasingColorShader constructor are the R,G,B and Alpha components of the first color (here, a solid red) and the four next ones are the R,G,B and Alpha components of the second color (here, a solid green). We just need to actually create the strokes from our visible <a class="el" href="classViewEdge.html">ViewEdge</a> and our shaders list by calling the <a class="el" href="classOperators.html#e63ecba5e5ef23d6296a6ac3ac7f31d1">Operators::create()</a> operator: <br>
 <div class="fragment"><pre class="fragment"><a class="code" href="classOperators.html">Operators</a>.create(TrueUP1D(), shaders_list)
</pre></div> <br>
 The TrueUP1D predicate passed as the first argument of this operator returns true for any <a class="el" href="classInterface1D.html">Interface1D</a>. It just means we want to build a <a class="el" href="classStroke.html">Stroke</a> for every <a class="el" href="classViewEdge.html">ViewEdge</a>. The second argument is the list of Shaders we just built. Here is how the whole Style Module now looks like: <br>
 <div class="fragment"><pre class="fragment">from Freestyle <span class="keyword">import</span> *

<a class="code" href="classOperators.html">Operators</a>.select(QuantitativeInvisibilityUP1D(0))
shaders_list =  [IncreasingColorShader(1,0,0,1, 0,1,0,1)]
<a class="code" href="classOperators.html">Operators</a>.create(TrueUP1D(), shaders_list)
</pre></div> <br>
 We can compute the strokes from the <a class="el" href="classViewMap.html">ViewMap</a> and this Style Module by selecting the Tools &gt; "Compute Strokes" in the main window. Here is the result you should get:  
<table align="center" width="50%" border=0 cellpadding=0 cellspacing=0>
  <tr>
    <td align="center" width="100%"><img src="tutorial_ViewEdges.jpg" width="100%"></td>
  </tr>
  <tr>
    <td align="center">The strokes built using StyleModule0.py</td>
  </tr>
</table>
 <br>
 We can increase a little bit the thickness of our strokes using the ConstantThicknessShader shader. Let us add this shader into our shaders list: <br>
 <div class="fragment"><pre class="fragment">shaders_list =  [IncreasingColorShader(1,0,0,1, 0,1,0,1),
                 ConstantThicknessShader(4)]
</pre></div> <br>
 Here is our new result:  
<table align="center" width="50%" border=0 cellpadding=0 cellspacing=0>
  <tr>
    <td align="center" width="100%"><img src="tutorial_ViewEdges2.jpg" width="100%"></td>
  </tr>
  <tr>
    <td align="center">The strokes built using StyleModule0.py including the ConstantThicknessShader</td>
  </tr>
</table>
 <br>
 Because no chaining was specified, each stroke corresponds to a single <a class="el" href="classViewEdge.html">ViewEdge</a>, which leads to short strokes. Let us use a chaining based on the <a class="el" href="classChainSilhouetteIterator.html">ChainSilhouetteIterator</a> iterator, which chains together all connected visible ViewEdges of same nature. We choose a bidirectional chaining algorithm in order to build the longest possible strokes. We also want our chains to stop whenever we reach a non visible <a class="el" href="classViewEdge.html">ViewEdge</a>. Here is the corresponding chaining code: <br>
 <div class="fragment"><pre class="fragment"><a class="code" href="classOperators.html">Operators</a>.bidirectionalChain(<a class="code" href="classChainSilhouetteIterator.html">ChainSilhouetteIterator</a>(), NotUP1D(QuantitativeInvisibilityUP1D(0)))
</pre></div> <br>
 This operation comes directly after the selection. Thus, we start a new <a class="el" href="classChain.html">Chain</a> for every <a class="el" href="classViewEdge.html">ViewEdge</a> of the selection that has not already been processed. Here is how the whole Style Module now looks like: <br>
 <div class="fragment"><pre class="fragment">from Freestyle <span class="keyword">import</span> *

<a class="code" href="classOperators.html">Operators</a>.select(QuantitativeInvisibilityUP1D(0))
<a class="code" href="classOperators.html">Operators</a>.bidirectionalChain(<a class="code" href="classChainSilhouetteIterator.html">ChainSilhouetteIterator</a>(), NotUP1D(QuantitativeInvisibilityUP1D(0)))
shaders_list =  [IncreasingColorShader(1,0,0,1, 0,1,0,1)]
<a class="code" href="classOperators.html">Operators</a>.create(TrueUP1D(), shaders_list)
</pre></div> <br>
 And here is our new result:  
<table align="center" width="50%" border=0 cellpadding=0 cellspacing=0>
  <tr>
    <td align="center" width="100%"><img src="tutorial_Strokes.jpg" width="100%"></td>
  </tr>
  <tr>
    <td align="center">The strokes built using the chaining operator in StyleModule0.py</td>
  </tr>
</table>
 <br>
<h2><a class="anchor" name="s4">
A more complex example [to come]</a></h2>
<ul>
<li>Using Splitting</li><li>Using sorting + density</li><li>Organising a Style into several layers (StyleModules)</li></ul>
<h2><a class="anchor" name="s5">
Implementing our own objects.</a></h2>
So far we only used C++ predefined objects. However, our operators are programmable in the sense that you can program your own predicates, iterators, shaders, etc. and use them instead of the ones that were seen above. For instance, assuming that you want a shader that assigns a thickness proportionally to the inverse of the depth, you need to code this shader as well as any needed function yourself. The idea is that all the basic programming components required to write powerful style rules are provided that should. For instance, all information access is provided so that you can define any new information-based Function, Predicate or Shader, and as our style description language is Python, these ones can be of arbitrary complexity. <br>
 For modularity issues, we recommend separating the Functions, Predicates and Shaders definitions from the Style Module files. Indeed, a shader might be used in more than one Style Module. Therefore, we suppose here that any Function, Predicate or Shader will be written in a new file.<p>
Implementing your own functions often implies the use of many of the functions provided to access the information (eg, 3D or 2D coordinates, depth discontinuity, line nature, etc.) It is therefore essential to have a basic idea of how these mechanisms work: Information can be accessed from two high-level types of elements: points (OD elements) or lines (1D elements). In practice, 0D elements can be arbitrary points along a <a class="el" href="classViewEdge.html">ViewEdge</a>, <a class="el" href="classViewVertex.html">ViewVertex</a> or <a class="el" href="classStrokeVertex.html">StrokeVertex</a> (those are not exclusive types) and 1D elements can be either <a class="el" href="classViewEdge.html">ViewEdge</a>, <a class="el" href="classChain.html">Chain</a> or <a class="el" href="classStroke.html">Stroke</a>. In the general case, you don't need to distinguish between one type or another within a same category: Elements that are manipulated are therefore either 0D elements or 1D elements (it is possible to retrieve the specialized object from them when necessary). The OD elements are manipulated through the <a class="el" href="classInterface0DIterator.html">Interface0DIterator</a> type, an iterator over the points of a 1D element (Iterators instead of simple points, as they encapsulate a 1D context that might be needed in the context of many information queries), and the 1D elements are manipulated through the <a class="el" href="classInterface1D.html">Interface1D</a> type.<h2><a class="anchor" name="s6">
Implementing your own Functions</a></h2>
Among the functions provided to retrieve information from points, we find the GetProjectedZF0D functor that returns the depth value (in camera space) for any <a class="el" href="classInterface0DIterator.html">Interface0DIterator</a>. This function returns a value between 0 and 1. Let us implement directly in python a simple function that returns the "inverse depth", 1-z. <br>
<p>
First, as for any python file that would need objects defined in Freestyle, we need to import the Freestyle module: <br>
 <div class="fragment"><pre class="fragment">from Freestyle <span class="keyword">import</span> *
</pre></div> <br>
 We choose to call our Functor pyGetInverseProjectedZF0D. The "py" prefixe indicating that the functor was defined in Python and the "F0D" suffixe indicates that we're dealing with a Unary Function working in 0D (on points). As any functor that acts on <a class="el" href="classInterface0DIterator.html">Interface0DIterator</a>, we must inherit from <a class="el" href="classUnaryFunction0D.html">UnaryFunction0D</a>. In Python, there are different <a class="el" href="classUnaryFunction0D.html">UnaryFunction0D</a> depending on the Function return value type. Here, we will return a double, therefore, we inherit from UnaryFunction0DDouble. Here is the declaration line for our functor: <br>
 <div class="fragment"><pre class="fragment"><span class="keyword">class </span>pyGetInverseProjectedZF0D(UnaryFunction0DDouble):
</pre></div> <br>
 We must now overload the "()" operator. In python the corresponding method is named <em>__call__</em>. Thus, our functor skeleton looks like this: <br>
 <div class="fragment"><pre class="fragment"><span class="keyword">class </span>pyGetInverseProjectedZF0D(UnaryFunction0DDouble):
        def __call__(self, inter):
                ## add the code here
                return 0
</pre></div> <br>
 If needed, the constructor might be overloaded through the <em>__init__</em> method: <br>
 <div class="fragment"><pre class="fragment"><span class="keyword">class </span>pyGetInverseProjectedZF0D(UnaryFunction0DDouble):
        def __init__(self):
                ## add initialization code here
                
        def __call__(self, inter):
                ## add the code here
                return 0
</pre></div> <br>
 To compute the inverse projected Z we use the GetProjectedZF0D functor: <br>
 <div class="fragment"><pre class="fragment"><span class="keyword">class </span>pyGetInverseProjectedZF0D(UnaryFunction0DDouble):
        def __init__(self):
                ## add initialization code here
                
        def __call__(self, inter):
                func = GetProjectedZF0D()
                return 1.0-func(inter)
</pre></div> <br>
 We must recall here that our functions are in reality functors and must therefore be instanciated (as objects) before use. <br>
 We're done! Any Style Module or python file that wants to use this function must import the module in which it is defined. For example, we can use this Functor in the recursive split operator in order to split the Chains at the max depth value: <br>
 <div class="fragment"><pre class="fragment">func = pyGetInverseProjectedZF0D()
<a class="code" href="classOperators.html">Operators</a>.recursiveSplit(func, NotUP1D(pyHigherLengthUP1D(5)), 5)
</pre></div> <br>
 This code evaluates pyGetInverseProjectedZF0D every 5 units along each <a class="el" href="classChain.html">Chain</a> and splits in two at the point realizing the min value. We stop splitting when Chains length are less than 5 units.<h2><a class="anchor" name="s7">
Implementing your own Predicates</a></h2>
In the previous example we needed a predicate working on <a class="el" href="classInterface1D.html">Interface1D</a> and telling whether its length was higher than a certain value or not. Let us code this Predicate in python. First, as for any python file that would need objects defined in Freestyle, we need to import the Freestyle module: <br>
 <div class="fragment"><pre class="fragment">from Freestyle <span class="keyword">import</span> *
</pre></div> <br>
 We call this predicate pyHigherLengthUP1D. The "py" prefix indicating that we're dealing with a predicate defined in python, the "UP1D" suffix indicating that it is a Unary Predicate working on 1D elements. As any unary predicate of this kind, it must inherit from UnaryPredicateUP1D. Therefore, the declaration looks like this: <br>
 <div class="fragment"><pre class="fragment"><span class="keyword">class </span>pyHigherLengthUP1D(UnaryPredicate1D):
</pre></div> <br>
 We want the user to have control over the threshold length value. It must therefore be a parameter given at the predicate construction: <br>
 <div class="fragment"><pre class="fragment"><span class="keyword">class </span>pyHigherLengthUP1D(UnaryPredicate1D):
        def __init__(self,l):
                UnaryPredicate1D.__init__(self)
                self._l = l
</pre></div> <br>
 The constructor (<em>__init__</em>) takes an argument <em>l</em> and uses it to initialize a data member called <em>_l</em>. As for Functors, the work must be done in the () operator, i.e. the <em>__call__</em> method in python: <br>
 <div class="fragment"><pre class="fragment"><span class="keyword">class </span>pyHigherLengthUP1D(UnaryPredicate1D):
        def __init__(self,l):
                UnaryPredicate1D.__init__(self)
                self._GetLength2D = GetLength2DF1D()
                self._l = l
                
        def __call__(self, inter):
                return (self._GetLength2D(inter) &gt; self._l)
</pre></div> <br>
 The implementation uses the GetLength2DF1D() access function provided for any <a class="el" href="classInterface1D.html">Interface1D</a> to get its 2D length. <br>
 Here is a code example of selection using this Predicate: <br>
 <div class="fragment"><pre class="fragment"><a class="code" href="classOperators.html">Operators</a>.select(pyHigherLengthUP1D(20))
</pre></div> <br>
 This operation selects the active <a class="el" href="classInterface1D.html">Interface1D</a> whose length is higher than 20 units.<h2><a class="anchor" name="s8">
Implementing your own Shaders</a></h2>
The objects that need to be redefined the most often are shaders. Indeed, they're responsible for a great part of the style and must often produce very specific visual effects. Implementing a Shader might take a lot of time and be very complex depending on the shading you want to achieve. We'll illustrate this task on a simple example. Suppose we want to write a Shader that assigns to the vertices of a <a class="el" href="classStroke.html">Stroke</a> a thickness that linearly goes from a thickness t1 to a thickness t2 between the begining and the end of the <a class="el" href="classStroke.html">Stroke</a>. Once again, we first need to import the Freestyle module: <br>
 <div class="fragment"><pre class="fragment">from Freestyle <span class="keyword">import</span> *
</pre></div> <br>
 We chose to call this Shader, pyVaryingThicknessShader. "py" for python, "Shader" for ... shader. It must inherit from the Shader base class, <a class="el" href="classStrokeShader.html">StrokeShader</a>: <br>
 <div class="fragment"><pre class="fragment"><span class="keyword">class </span>pyVaryingThicknessShader(StrokeShader):
</pre></div> <br>
 This shader must offer to the user the control over the two thicknesses that will be used, therefore we must redefine the constructor: <br>
 <div class="fragment"><pre class="fragment"><span class="keyword">class </span>pyVaryingThicknessShader(StrokeShader):
         def __init__(self, t1, t2):
                StrokeShader.__init__(self)
                self._t1 = t1
                self._t2 = t2
</pre></div> <br>
 The two thicknesses are stored in the data members <em>_t1</em> and <em>_t2</em>. The shading implementation occurs in the <em>shade</em> method, that we must implement. This method takes as argument the <a class="el" href="classStroke.html">Stroke</a> that must be shaded (see <a class="el" href="classStrokeShader.html#744abef39fb1953f24e61bff1afd7c95">StrokeShader::shade()</a>). The basic way to achieve any shading operation consists in iterating over the StrokeVertices of the <a class="el" href="classStroke.html">Stroke</a> and to modify each one's <a class="el" href="classStrokeAttribute.html">StrokeAttribute</a>. Here is the python code for the skeleton of such an iteration: <br>
 <div class="fragment"><pre class="fragment">it = ioStroke.strokeVerticesBegin()
<span class="keywordflow">while</span> it.isEnd() == 0:
        att = it.getObject().attribute()
<span class="preprocessor">        ## perform here any attribute modification</span>
<span class="preprocessor">        it.increment()</span>
</pre></div> <br>
 And here is our complete shader: <br>
 <div class="fragment"><pre class="fragment"><span class="keyword">class </span>pyVaryingThicknessShader(StrokeShader):
         def __init__(self, t1, t2):
                StrokeShader.__init__(self)
                self._t1 = t1
                self._t2 = t2
                
        def shade(self, stroke):
                n = stroke.strokeVerticesSize()
                i = 0
                it = stroke.strokeVerticesBegin()
                it_end = stroke.strokeVerticesEnd()
                while it.isEnd() == 0:
                        att = it.getObject().attribute()
                        c = float(i)/float(n)
                        t = (1.0 - c)*self._t1 + c * self._t2
                        att.setThickness(t/2.0, t/2.0)
                        i = i+1
                        it.increment()
</pre></div> <br>
 This shader can then be used as any other shader in a Style Module: <br>
 <div class="fragment"><pre class="fragment">shaders_list = [ConstantColorShader(1,0,0,1),
                pyVaryingThicknessShader(2, 10)]
<a class="code" href="classOperators.html">Operators</a>.create(TrueUP1D(), shaders_list)                
</pre></div> <br>
 This will build red strokes whose thickness varies linearly from 2 to 10 units. </div>
<div align="center">
<div class="brighttitle"><hr/></div>
<div id='Footer'><table width='90%' border='0' class='footer'><tr>
<td align='left'>
Last modified 6 Mar 2008 </td><td align='center'>
<a href="http://sourceforge.net"><img src="http://sourceforge.net/sflogo.php?group_id=124602&amp;type=1" width="88" height="31" border="0" alt="SourceForge.net Logo"/></a>

</td>
<td align='right'>&copy; <a href="http://artis.imag.fr/Members/Stephane.Grabli">Stephane Grabli</a></td></tr></table>
</div>
</div>
</body>
</html>
