<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//$LANGUAGE"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Freestyle: Operators Class Reference</title>
<link rel="stylesheet" href="grey.css" type="text/css">
</head>
<body>

<b>
<table width='100%' border='0' cellspacing='0' cellpadding='0'>
<tr>
<td align='center'><a href="http://freestyle.sourceforge.net">h<font class="brighttitle"> o m e</font></a></td>
<td align='center'><a href="index.html">d<font class="brighttitle"> o c u m e n t a t i o n</font></a></td>
<td align='center'><a href="hierarchy.html">c<font class="brighttitle"> l a s s   </font>h <font class="brighttitle"> i e r a r c h y</font></a></td>
</tr>
</table>
<div class="brighttitle"><hr/></div>
</b>
<div class="corpus">
<!-- Generated by Doxygen 1.5.1 -->
<h1>Operators Class Reference</h1><!-- doxytag: class="Operators" --><code>#include &lt;<a class="el" href="Operators_8h-source.html">Operators.h</a>&gt;</code>
<p>
<a href="classOperators-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Class defining the operators used in a style module. There are 4 classes of operators: Selection, Chaining, Splitting and Creating. All these operators are user controlled in the scripting language through Functors, Predicates and Shaders that are taken as arguments. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOperators.html#3354b2c9bd94e3225c17fb283d4394fe">select</a> (<a class="el" href="classUnaryPredicate1D.html">UnaryPredicate1D</a> &amp;pred)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOperators.html#fbe663c9a95ec4dc5b88d8483ff4aa4a">chain</a> (<a class="el" href="classViewEdgeInternal_1_1ViewEdgeIterator.html">ViewEdgeInternal::ViewEdgeIterator</a> &amp;it, <a class="el" href="classUnaryPredicate1D.html">UnaryPredicate1D</a> &amp;pred, <a class="el" href="classUnaryFunction1D.html">UnaryFunction1D</a>&lt; void &gt; &amp;modifier)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOperators.html#77246d3887f9e7694f55a37506f7fa52">chain</a> (<a class="el" href="classViewEdgeInternal_1_1ViewEdgeIterator.html">ViewEdgeInternal::ViewEdgeIterator</a> &amp;it, <a class="el" href="classUnaryPredicate1D.html">UnaryPredicate1D</a> &amp;pred)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOperators.html#540314214b4bf187c8c728710e692325">bidirectionalChain</a> (<a class="el" href="classChainingIterator.html">ChainingIterator</a> &amp;it, <a class="el" href="classUnaryPredicate1D.html">UnaryPredicate1D</a> &amp;pred)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOperators.html#9bde96bb28296b1dd2ae0fbdd2090821">bidirectionalChain</a> (<a class="el" href="classChainingIterator.html">ChainingIterator</a> &amp;it)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOperators.html#7f8829e50aa72285f512b5feb307e129">sequentialSplit</a> (<a class="el" href="classUnaryPredicate0D.html">UnaryPredicate0D</a> &amp;startingPred, <a class="el" href="classUnaryPredicate0D.html">UnaryPredicate0D</a> &amp;stoppingPred, float sampling=0.f)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOperators.html#b23e29eb1668ec0335a4b7291c38cba9">sequentialSplit</a> (<a class="el" href="classUnaryPredicate0D.html">UnaryPredicate0D</a> &amp;pred, float sampling=0.f)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOperators.html#0d7f585788448da0743666003cc7de96">recursiveSplit</a> (<a class="el" href="classUnaryFunction0D.html">UnaryFunction0D</a>&lt; double &gt; &amp;func, <a class="el" href="classUnaryPredicate1D.html">UnaryPredicate1D</a> &amp;pred, float sampling=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOperators.html#1be39d057428597ae78cefed8c193604">recursiveSplit</a> (<a class="el" href="classUnaryFunction0D.html">UnaryFunction0D</a>&lt; double &gt; &amp;func, <a class="el" href="classUnaryPredicate0D.html">UnaryPredicate0D</a> &amp;pred0d, <a class="el" href="classUnaryPredicate1D.html">UnaryPredicate1D</a> &amp;pred, float sampling=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOperators.html#326afe6fe5de4207d63b864a6f824c7a">sort</a> (<a class="el" href="classBinaryPredicate1D.html">BinaryPredicate1D</a> &amp;pred)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOperators.html#e63ecba5e5ef23d6296a6ac3ac7f31d1">create</a> (<a class="el" href="classUnaryPredicate1D.html">UnaryPredicate1D</a> &amp;pred, vector&lt; <a class="el" href="classStrokeShader.html">StrokeShader</a> * &gt; shaders)</td></tr>

</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="3354b2c9bd94e3225c17fb283d4394fe"></a><!-- doxytag: member="Operators::select" ref="3354b2c9bd94e3225c17fb283d4394fe" args="(UnaryPredicate1D &amp;pred)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void select           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUnaryPredicate1D.html">UnaryPredicate1D</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pred</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Selects the ViewEdges of the <a class="el" href="classViewMap.html">ViewMap</a> verifying a specified condition. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pred</em>&nbsp;</td><td>The predicate expressing this condition </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fbe663c9a95ec4dc5b88d8483ff4aa4a"></a><!-- doxytag: member="Operators::chain" ref="fbe663c9a95ec4dc5b88d8483ff4aa4a" args="(ViewEdgeInternal::ViewEdgeIterator &amp;it, UnaryPredicate1D &amp;pred, UnaryFunction1D&lt; void &gt; &amp;modifier)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void chain           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classViewEdgeInternal_1_1ViewEdgeIterator.html">ViewEdgeInternal::ViewEdgeIterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUnaryPredicate1D.html">UnaryPredicate1D</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUnaryFunction1D.html">UnaryFunction1D</a>&lt; void &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>modifier</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a set of chains from the current set of ViewEdges. Each <a class="el" href="classViewEdge.html">ViewEdge</a> of the current list starts a new chain. The chaining operator then iterates over the ViewEdges of the <a class="el" href="classViewMap.html">ViewMap</a> using the user specified iterator. This operator only iterates using the increment operator and is therefore unidirectional. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>it</em>&nbsp;</td><td>The iterator on the ViewEdges of the <a class="el" href="classViewMap.html">ViewMap</a>. It contains the chaining rule. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pred</em>&nbsp;</td><td>The predicate on the <a class="el" href="classViewEdge.html">ViewEdge</a> that expresses the stopping condition. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>modifier</em>&nbsp;</td><td>A function that takes a <a class="el" href="classViewEdge.html">ViewEdge</a> as argument and that is used to modify the processed <a class="el" href="classViewEdge.html">ViewEdge</a> state (the timestamp incrementation is a typical illustration of such a modifier) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="77246d3887f9e7694f55a37506f7fa52"></a><!-- doxytag: member="Operators::chain" ref="77246d3887f9e7694f55a37506f7fa52" args="(ViewEdgeInternal::ViewEdgeIterator &amp;it, UnaryPredicate1D &amp;pred)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void chain           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classViewEdgeInternal_1_1ViewEdgeIterator.html">ViewEdgeInternal::ViewEdgeIterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUnaryPredicate1D.html">UnaryPredicate1D</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pred</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a set of chains from the current set of ViewEdges. Each <a class="el" href="classViewEdge.html">ViewEdge</a> of the current list starts a new chain. The chaining operator then iterates over the ViewEdges of the <a class="el" href="classViewMap.html">ViewMap</a> using the user specified iterator. This operator only iterates using the increment operator and is therefore unidirectional. This chaining operator is different from the previous one because it doesn't take any modifier as argument. Indeed, the time stamp (insuring that a <a class="el" href="classViewEdge.html">ViewEdge</a> is processed one time) is automatically managed in this case. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>it</em>&nbsp;</td><td>The iterator on the ViewEdges of the <a class="el" href="classViewMap.html">ViewMap</a>. It contains the chaining rule. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pred</em>&nbsp;</td><td>The predicate on the <a class="el" href="classViewEdge.html">ViewEdge</a> that expresses the stopping condition. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="540314214b4bf187c8c728710e692325"></a><!-- doxytag: member="Operators::bidirectionalChain" ref="540314214b4bf187c8c728710e692325" args="(ChainingIterator &amp;it, UnaryPredicate1D &amp;pred)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bidirectionalChain           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classChainingIterator.html">ChainingIterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUnaryPredicate1D.html">UnaryPredicate1D</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pred</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a set of chains from the current set of ViewEdges. Each <a class="el" href="classViewEdge.html">ViewEdge</a> of the current list potentially starts a new chain. The chaining operator then iterates over the ViewEdges of the <a class="el" href="classViewMap.html">ViewMap</a> using the user specified iterator. This operator iterates both using the increment and decrement operators and is therefore bidirectional. This operator works with a <a class="el" href="classChainingIterator.html">ChainingIterator</a> which contains the chaining rules. It is this last one which can be told to chain only edges that belong to the selection or not to process twice a <a class="el" href="classViewEdge.html">ViewEdge</a> during the chaining. Each time a <a class="el" href="classViewEdge.html">ViewEdge</a> is added to a chain, its chaining time stamp is incremented. This allows you to keep track of the number of chains to which a <a class="el" href="classViewEdge.html">ViewEdge</a> belongs to. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>it</em>&nbsp;</td><td>The <a class="el" href="classChainingIterator.html">ChainingIterator</a> on the ViewEdges of the <a class="el" href="classViewMap.html">ViewMap</a>. It contains the chaining rule. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pred</em>&nbsp;</td><td>The predicate on the <a class="el" href="classViewEdge.html">ViewEdge</a> that expresses the stopping condition. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9bde96bb28296b1dd2ae0fbdd2090821"></a><!-- doxytag: member="Operators::bidirectionalChain" ref="9bde96bb28296b1dd2ae0fbdd2090821" args="(ChainingIterator &amp;it)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bidirectionalChain           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classChainingIterator.html">ChainingIterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>it</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The only difference with the above bidirectional chaining algorithm is that we don't need to pass a stopping criterion. This might be desirable when the stopping criterion is already contained in the iterator definition. Builds a set of chains from the current set of ViewEdges. Each <a class="el" href="classViewEdge.html">ViewEdge</a> of the current list potentially starts a new chain. The chaining operator then iterates over the ViewEdges of the <a class="el" href="classViewMap.html">ViewMap</a> using the user specified iterator. This operator iterates both using the increment and decrement operators and is therefore bidirectional. This operator works with a <a class="el" href="classChainingIterator.html">ChainingIterator</a> which contains the chaining rules. It is this last one which can be told to chain only edges that belong to the selection or not to process twice a <a class="el" href="classViewEdge.html">ViewEdge</a> during the chaining. Each time a <a class="el" href="classViewEdge.html">ViewEdge</a> is added to a chain, its chaining time stamp is incremented. This allows you to keep track of the number of chains to which a <a class="el" href="classViewEdge.html">ViewEdge</a> belongs to. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>it</em>&nbsp;</td><td>The <a class="el" href="classChainingIterator.html">ChainingIterator</a> on the ViewEdges of the <a class="el" href="classViewMap.html">ViewMap</a>. It contains the chaining rule. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7f8829e50aa72285f512b5feb307e129"></a><!-- doxytag: member="Operators::sequentialSplit" ref="7f8829e50aa72285f512b5feb307e129" args="(UnaryPredicate0D &amp;startingPred, UnaryPredicate0D &amp;stoppingPred, float sampling=0.f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void sequentialSplit           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUnaryPredicate0D.html">UnaryPredicate0D</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>startingPred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUnaryPredicate0D.html">UnaryPredicate0D</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stoppingPred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>sampling</em> = <code>0.f</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Splits each chain of the current set of chains in a sequential way. The points of each chain are processed (with a specified sampling) sequentially. Each time a user specified starting condition is verified, a new chain begins and ends as soon as a user-defined stopping predicate is verified. This allows chains overlapping rather than chains partitioning. The first point of the initial chain is the first point of one of the resulting chains. The splitting ends when no more chain can start. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>startingPred</em>&nbsp;</td><td>The predicate on a point that expresses the starting condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stoppingPred</em>&nbsp;</td><td>The predicate on a point that expresses the stopping condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sampling</em>&nbsp;</td><td>The resolution used to sample the chain for the predicates evaluation. (The chain is not actually resampled, a virtual point only progresses along the curve using this resolution) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b23e29eb1668ec0335a4b7291c38cba9"></a><!-- doxytag: member="Operators::sequentialSplit" ref="b23e29eb1668ec0335a4b7291c38cba9" args="(UnaryPredicate0D &amp;pred, float sampling=0.f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void sequentialSplit           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUnaryPredicate0D.html">UnaryPredicate0D</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>sampling</em> = <code>0.f</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Splits each chain of the current set of chains in a sequential way. The points of each chain are processed (with a specified sampling) sequentially and each time a user specified condition is verified, the chain is split into two chains. The resulting set of chains is a partition of the initial chain <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pred</em>&nbsp;</td><td>The predicate on a point that expresses the splitting condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sampling</em>&nbsp;</td><td>The resolution used to sample the chain for the predicate evaluation. (The chain is not actually resampled, a virtual point only progresses along the curve using this resolution) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0d7f585788448da0743666003cc7de96"></a><!-- doxytag: member="Operators::recursiveSplit" ref="0d7f585788448da0743666003cc7de96" args="(UnaryFunction0D&lt; double &gt; &amp;func, UnaryPredicate1D &amp;pred, float sampling=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void recursiveSplit           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUnaryFunction0D.html">UnaryFunction0D</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUnaryPredicate1D.html">UnaryPredicate1D</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>sampling</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Splits the current set of chains in a recursive way. We process the points of each chain (with a specified sampling) to find the point minimizing a specified function. The chain is split in two at this point and the two new chains are processed in the same way. The recursivity level is controlled through a predicate 1D that expresses a stopping condition on the chain that is about to be processed. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>func</em>&nbsp;</td><td>The Unary Function evaluated at each point of the chain. The splitting point is the point minimizing this function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pred</em>&nbsp;</td><td>The Unary Predicate ex pressing the recursivity stopping condition. This predicate is evaluated for each curve before it actually gets split. If pred(chain) is true, the curve won't be split anymore. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sampling</em>&nbsp;</td><td>The resolution used to sample the chain for the predicates evaluation. (The chain is not actually resampled, a virtual point only progresses along the curve using this resolution) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1be39d057428597ae78cefed8c193604"></a><!-- doxytag: member="Operators::recursiveSplit" ref="1be39d057428597ae78cefed8c193604" args="(UnaryFunction0D&lt; double &gt; &amp;func, UnaryPredicate0D &amp;pred0d, UnaryPredicate1D &amp;pred, float sampling=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void recursiveSplit           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUnaryFunction0D.html">UnaryFunction0D</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUnaryPredicate0D.html">UnaryPredicate0D</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pred0d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUnaryPredicate1D.html">UnaryPredicate1D</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>sampling</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Splits the current set of chains in a recursive way. We process the points of each chain (with a specified sampling) to find the point minimizing a specified function. The chain is split in two at this point and the two new chains are processed in the same way. The user can specify a 0D predicate to make a first selection on the points that can potentially be split. A point that doesn't verify the 0D predicate won't be candidate in realizing the min. The recursivity level is controlled through a predicate 1D that expresses a stopping condition on the chain that is about to be processed. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>func</em>&nbsp;</td><td>The Unary Function evaluated at each point of the chain. The splitting point is the point minimizing this function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pred0d</em>&nbsp;</td><td>The Unary Predicate 0D used to select the candidate points where the split can occur. For example, it is very likely that would rather have your chain splitting around its middle point than around one of its extremities. A 0D predicate working on the curvilinear abscissa allows to add this kind of constraints. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pred</em>&nbsp;</td><td>The Unary Predicate ex pressing the recursivity stopping condition. This predicate is evaluated for each curve before it actually gets split. If pred(chain) is true, the curve won't be split anymore. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sampling</em>&nbsp;</td><td>The resolution used to sample the chain for the predicates evaluation. (The chain is not actually resampled, a virtual point only progresses along the curve using this resolution) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="326afe6fe5de4207d63b864a6f824c7a"></a><!-- doxytag: member="Operators::sort" ref="326afe6fe5de4207d63b864a6f824c7a" args="(BinaryPredicate1D &amp;pred)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void sort           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBinaryPredicate1D.html">BinaryPredicate1D</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pred</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sorts the current set of chains (or viewedges) according to the comparison predicate given as argument. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pred</em>&nbsp;</td><td>The binary predicate used for the comparison </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e63ecba5e5ef23d6296a6ac3ac7f31d1"></a><!-- doxytag: member="Operators::create" ref="e63ecba5e5ef23d6296a6ac3ac7f31d1" args="(UnaryPredicate1D &amp;pred, vector&lt; StrokeShader * &gt; shaders)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void create           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUnaryPredicate1D.html">UnaryPredicate1D</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classStrokeShader.html">StrokeShader</a> * &gt;&nbsp;</td>
          <td class="paramname"> <em>shaders</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates and shades the strokes from the current set of chains. A predicate can be specified to make a selection pass on the chains. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pred</em>&nbsp;</td><td>The predicate that a chain must verify in order to be transform as a stroke </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>shaders</em>&nbsp;</td><td>The list of shaders used to shade the strokes </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Operators_8h-source.html">Operators.h</a></ul>
</div>
<div align="center">
<div class="brighttitle"><hr/></div>
<div id='Footer'><table width='90%' border='0' class='footer'><tr>
<td align='left'>
Last modified 6 Mar 2008 </td><td align='center'>
<a href="http://sourceforge.net"><img src="http://sourceforge.net/sflogo.php?group_id=124602&amp;type=1" width="88" height="31" border="0" alt="SourceForge.net Logo"/></a>

</td>
<td align='right'>&copy; <a href="http://artis.imag.fr/Members/Stephane.Grabli">Stephane Grabli</a></td></tr></table>
</div>
</div>
</body>
</html>
