<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//$LANGUAGE"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Freestyle: Style Module Documentation</title>
<link rel="stylesheet" href="grey.css" type="text/css">
</head>
<body>

<b>
<table width='100%' border='0' cellspacing='0' cellpadding='0'>
<tr>
<td align='center'><a href="http://freestyle.sourceforge.net">h<font class="brighttitle"> o m e</font></a></td>
<td align='center'><a href="index.html">d<font class="brighttitle"> o c u m e n t a t i o n</font></a></td>
<td align='center'><a href="hierarchy.html">c<font class="brighttitle"> l a s s   </font>h <font class="brighttitle"> i e r a r c h y</font></a></td>
</tr>
</table>
<div class="brighttitle"><hr/></div>
</b>
<div class="corpus">
<!-- Generated by Doxygen 1.5.1 -->
<h1><a class="anchor" name="StyleModuleDocumentation">Style Module Documentation</a></h1><h2><a class="anchor" name="smds1">
What is a style module ?</a></h2>
A Style Module is the piece of code responsible for the stylization of a part of the drawing. Basically, it applies a style selectively to the lines of the drawing. The input of a Style Module is the <a class="el" href="classViewMap.html">ViewMap</a>. The output is a set of strokes. A Style Module is structured as a pipeline of identified operations that allow to build strokes from the edges of the <a class="el" href="classViewMap.html">ViewMap</a>. There are 5 kinds of operations:<ul>
<li>Selection (<a class="el" href="classOperators.html#3354b2c9bd94e3225c17fb283d4394fe">Operators::select()</a>)</li><li>Chaining (<a class="el" href="classOperators.html#fbe663c9a95ec4dc5b88d8483ff4aa4a">Operators::chain()</a>, <a class="el" href="classOperators.html#540314214b4bf187c8c728710e692325">Operators::bidirectionalChain()</a>)</li><li>Splitting (<a class="el" href="classOperators.html#7f8829e50aa72285f512b5feb307e129">Operators::sequentialSplit()</a>, <a class="el" href="classOperators.html#0d7f585788448da0743666003cc7de96">Operators::recursiveSplit()</a>)</li><li>Sorting (<a class="el" href="classOperators.html#326afe6fe5de4207d63b864a6f824c7a">Operators::sort()</a>)</li><li>Creation (<a class="el" href="classOperators.html#e63ecba5e5ef23d6296a6ac3ac7f31d1">Operators::create()</a>)</li></ul>
<p>
All these operations act on a set of 1D active elements. The different elements that can be active at some point of the pipeline are:<ul>
<li><a class="el" href="classViewEdge.html">ViewEdge</a></li><li><a class="el" href="classChain.html">Chain</a></li><li><a class="el" href="classStroke.html">Stroke</a></li></ul>
<p>
Initially, the set of active elements is the set of every <a class="el" href="classViewEdge.html">ViewEdge</a> of the <a class="el" href="classViewMap.html">ViewMap</a>.<h3><a class="anchor" name="ss11">
Selection</a></h3>
The selection operator parse every elements of the active set and keeps only the ones satisfying a certain predicate. The <a class="el" href="classOperators.html#3354b2c9bd94e3225c17fb283d4394fe">Operators::select()</a> operator takes as argument a unary predicate that works on any <a class="el" href="classInterface1D.html">Interface1D</a>. For example: <div class="fragment"><pre class="fragment"><a class="code" href="classOperators.html">Operators</a>.select(QuantitativeInvisibilityUP1D(0))
</pre></div> uses the QuantitativeInvisibilityUP1D predicate to select only the visible <a class="el" href="classViewEdge.html">ViewEdge</a>. The selection operator is designed to apply the style, that will be defined afterwards in the style module, selectively. <br>
<h3><a class="anchor" name="ss12">
Chaining</a></h3>
The chaining operators act on the active set of <a class="el" href="classViewEdge.html">ViewEdge</a> and allow the user to specify the topology of the future strokes. The idea is to implement an iterator to traverse the <a class="el" href="classViewMap.html">ViewMap</a> graph marching along ViewEdges. This iterator basically needs to tell which next <a class="el" href="classViewEdge.html">ViewEdge</a> to follow when at a given vertex. (see ViewEdgeIterator). Several such iterators are provided by the system (see <a class="el" href="classChainPredicateIterator.html">ChainPredicateIterator</a>, <a class="el" href="classChainSilhouetteIterator.html">ChainSilhouetteIterator</a>). The chaining operator also takes as input a UnaryPredicate working on <a class="el" href="classInterface1D.html">Interface1D</a> as a stopping criterion. If a <a class="el" href="classViewEdge.html">ViewEdge</a> satisfying this predicate is reached during the march along the graph, the chaining stops. The chaining can be unidirectional (<a class="el" href="classOperators.html#fbe663c9a95ec4dc5b88d8483ff4aa4a">Operators::chain()</a>) or bidirectional (<a class="el" href="classOperators.html#540314214b4bf187c8c728710e692325">Operators::bidirectionalChain()</a>). In the second case, the chain will propagate in the two directions from the starting edge. Here is a code example of a bidirectional chaining call: <div class="fragment"><pre class="fragment"><a class="code" href="classOperators.html">Operators</a>.bidirectionalChain(<a class="code" href="classChainSilhouetteIterator.html">ChainSilhouetteIterator</a>(), NotUP1D(QuantitativeInvisibilityUP1D(0)))
</pre></div> Here we use the <a class="el" href="classChainSilhouetteIterator.html">ChainSilhouetteIterator</a> as our chaining rule and we tell the chaining to stop as soon as a non visible <a class="el" href="classViewEdge.html">ViewEdge</a> is reached. The chaining operator processes the set of active <a class="el" href="classViewEdge.html">ViewEdge</a> in order (this set can previously be sorted using <a class="el" href="classOperators.html#326afe6fe5de4207d63b864a6f824c7a">Operators::sort()</a>). It starts a chain with the first <a class="el" href="classViewEdge.html">ViewEdge</a> of the set. Every <a class="el" href="classViewEdge.html">ViewEdge</a> involved in the chain we're building can be marked (In the previous example, the time stamp of each <a class="el" href="classViewEdge.html">ViewEdge</a> is modified by default), in order not to process two times the same <a class="el" href="classViewEdge.html">ViewEdge</a>. Once the chaining reaches a <a class="el" href="classViewEdge.html">ViewEdge</a> that satisfies the stopping predicate, the chain ends. The algorithm then examines the second <a class="el" href="classViewEdge.html">ViewEdge</a> of the list and checks its time stamp in order to know whether it already has been processed or not. If not, we start a new chain starting from this <a class="el" href="classViewEdge.html">ViewEdge</a>. This operation is repeted until the last <a class="el" href="classViewEdge.html">ViewEdge</a> of the active set was processed. Here is the chaining algorithm: <div class="fragment"><pre class="fragment">
for ve in the set of active ViewEdge:
  if !processed(ve)
    chain = BuildChain(ve, stoppingPredicate)
    add chain to the set of active chains
</pre></div> At the end of the chaining operation, the active set contains all the Chains (see <a class="el" href="classChain.html">Chain</a>) that were just built.<p>
<br>
<h3><a class="anchor" name="ss13">
Splitting</a></h3>
The Splitting operation can be used to refine the topology of each <a class="el" href="classChain.html">Chain</a>. Two kinds of splitting are available. The first one is the sequential splitting (<a class="el" href="classOperators.html#7f8829e50aa72285f512b5feb307e129">Operators::sequentialSplit()</a>). In its basic version, it parses the <a class="el" href="classChain.html">Chain</a> at a given arbitrary resolution and evaluates a unary predicate (working on points) at each point along the <a class="el" href="classChain.html">Chain</a>. Each time the predicate is satisfied, the chain is split into two chains. At the end of the sequential split operation, the active set of chains contain the new chains. <div class="fragment"><pre class="fragment"><a class="code" href="classOperators.html">Operators</a>.sequentialSplit(TrueUP0D(), 2)
</pre></div> In this example, the chain is split every 2 units. A more elaborated version uses two predicates instead of one: One to determine the starting point of the new chain and the other to determine its ending point. This second version can lead to a set of Chains that are disjoint or that overlap if the two predicates are different. (see <a class="el" href="classOperators.html#7f8829e50aa72285f512b5feb307e129">Operators::sequentialSplit()</a> for more details). <br>
<p>
The second kind of splitting is the recursive split (<a class="el" href="classOperators.html#0d7f585788448da0743666003cc7de96">Operators::recursiveSplit()</a>). For each <a class="el" href="classChain.html">Chain</a>, this operator evaluates a Function on the points along the <a class="el" href="classChain.html">Chain</a> at a given resolution looking for the point that realizes the maximum value for the Function. The <a class="el" href="classChain.html">Chain</a> is then split into two. The process is then repeted on each of the two new Chains recursively. The algorithm stops when the input <a class="el" href="classChain.html">Chain</a> satisfy a user-specified condition. <div class="fragment"><pre class="fragment">func = Curvature2DAngleF0D()
<a class="code" href="classOperators.html">Operators</a>.recursiveSplit(func, NotUP1D(HigherLengthUP1D(5)), 5)
</pre></div> In this code example, we recursively split the <a class="el" href="classChain.html">Chain</a> at points of highest 2D curvature. The curvature is evaluated for every points long the <a class="el" href="classChain.html">Chain</a> at a resolution of 5 units. A <a class="el" href="classChain.html">Chain</a> whose length is not higher than 5 units won't be split. <br>
<h3><a class="anchor" name="ss14">
Sorting</a></h3>
The sorting operator (<a class="el" href="classOperators.html#326afe6fe5de4207d63b864a6f824c7a">Operators::sort()</a>) allows the sorting of the active set of <a class="el" href="classInterface1D.html">Interface1D</a>. It takes as input a binary predicate used as an "&lt;" operator to order two <a class="el" href="classInterface1D.html">Interface1D</a>. <div class="fragment"><pre class="fragment"><a class="code" href="classOperators.html">Operators</a>.sort(Length2DBP1D())
</pre></div> In this code example, the sorting uses the Length2DBP1D binary predicate to sort the <a class="el" href="classInterface1D.html">Interface1D</a> by incresing 2D lengths. <br>
 The sorting is particularly useful when combined with causal density. Indeed, the causal density evaluates the density of the resulting image as it is modified. If we wish to use such a tool to decide to remove strokes whenever the local density is too high, it is important to control the order in which the strokes are drawn. In this case, we would use the sorting operator to insure that the most "important" lines are drawn first. <br>
<h3><a class="anchor" name="ss15">
Creation</a></h3>
Finally, the creation operator (<a class="el" href="classOperators.html#e63ecba5e5ef23d6296a6ac3ac7f31d1">Operators::create()</a>), takes the active set of Chains as input and build Strokes. It takes two arguments: The first one is a unary predicate that works on <a class="el" href="classInterface1D.html">Interface1D</a> that is designed to make a last selection on the set of chains. A <a class="el" href="classChain.html">Chain</a> that doesn't satisfy the condition won't lead to a <a class="el" href="classStroke.html">Stroke</a>. The second input is a list of Shaders that will be responsible for the shading of each built stroke. <div class="fragment"><pre class="fragment">shaders_list =  [
                StrokeTextureShader(<span class="stringliteral">"smoothAlpha.bmp"</span>, <a class="code" href="classStroke.html">Stroke</a>.OPAQUE_MEDIUM, 0),
                ConstantThicknessShader(2), 
                SamplingShader(5.0),
                ConstantColorShader(0.2,0.2,0.2,1), 
                ]
<a class="code" href="classOperators.html">Operators</a>.create(DensityUP1D(8,0.1, <a class="code" href="Interface1D_8h.html#cfa28acdaa41352ffd89be690a20933db8037c675dad16b9139e24e000143c78">MEAN</a>), shaders_list)
</pre></div> In this example, we use the DensityUP1D predicate to remove any <a class="el" href="classChain.html">Chain</a> whose mean density is higher than 0.1. For each stroke, we set the texture "smoothAlpha.bmp" with an OPAQUE_MEDIUM blending mode, we define a constant thickness of 2 units, we resample the stroke so that it has a point every 5 units and eventually assigns a dark grey constant color.<h2><a class="anchor" name="smds2">
What control do we have over this pipeline ?</a></h2>
[ In construction ]. The Style Module has a fixed pipeline structure. However, it offers a lot of controls through, first, the sequencing of the different pipeline control structures, and, second, through the definition of objects that are passed as argument all along the pipeline.<p>
<ul>
<li>Sequence the different pipeline control structures<ul>
<li>select, chain, split, sort, create</li></ul>
</li><li>Possibly implement<ul>
<li>Functions</li><li>Predicates</li><li>Shaders </li></ul>
</li></ul>
</div>
<div align="center">
<div class="brighttitle"><hr/></div>
<div id='Footer'><table width='90%' border='0' class='footer'><tr>
<td align='left'>
Last modified 6 Mar 2008 </td><td align='center'>
<a href="http://sourceforge.net"><img src="http://sourceforge.net/sflogo.php?group_id=124602&amp;type=1" width="88" height="31" border="0" alt="SourceForge.net Logo"/></a>

</td>
<td align='right'>&copy; <a href="http://artis.imag.fr/Members/Stephane.Grabli">Stephane Grabli</a></td></tr></table>
</div>
</div>
</body>
</html>
